#!/usr/bin/env bash
# Smart-SSL v1.2.6

set -Eeuo pipefail

APP="smart-ssl"
VERSION="1.2.6"

SMARTSSL_REPO="${SMARTSSL_REPO:-Nima786/Smart-SSL}"
SMARTSSL_BRANCH="${SMARTSSL_BRANCH:-main}"
SMARTSSL_RAW_BASE="https://raw.githubusercontent.com/${SMARTSSL_REPO}/${SMARTSSL_BRANCH}"
SMARTSSL_BIN="/usr/local/bin/${APP}"

CONF_DIR="/etc/${APP}"
DOM_DIR="${CONF_DIR}/domains"
MAIN_CONF="${CONF_DIR}/config.ini"
CF_CREDS="/root/.secrets/cloudflare.ini"
TMP_DIR="/run/${APP}"

DEFAULT_PROPAGATION=90
DEFAULT_KEY_MODE=600
DEFAULT_CERT_MODE=644

die() { echo "ERROR: $*" >&2; exit 1; }
have() { command -v "$1" >/dev/null 2>&1; }
ensure_root() { [[ ${EUID:-0} -eq 0 ]] || die "Run as root."; }
pause() { read -rp "Press Enter to continue..." _ || true; }

ensure_paths() {
  mkdir -p "$DOM_DIR" "$TMP_DIR"
  chmod 700 "$TMP_DIR"
  [[ -f "$MAIN_CONF" ]] || cat >"$MAIN_CONF" <<EOF
email=
propagation_seconds=${DEFAULT_PROPAGATION}
creds=${CF_CREDS}
EOF
}

read_conf() {
  unset "${!CFG_@}" || true
  while IFS='=' read -r k v; do
    [[ "$k" =~ ^[a-z_]+$ ]] || continue
    eval "CFG_${k^^}='${v}'"
  done < <(grep -E "^[a-z_]+=" "$MAIN_CONF" || true)
}

_valid_email()  { [[ "$1" =~ ^[^@[:space:]]+@[^@[:space:]]+\.[^@[:space:]]+$ ]]; }
_valid_domain() { [[ "$1" =~ ^([a-zA-Z0-9]([-a-zA-Z0-9]*[a-zA-Z0-9])?\.)+[A-Za-z]{2,}$ ]]; }

domain_conf_path() { echo "${DOM_DIR}/$1.conf"; }
lineage_path()     { echo "/etc/letsencrypt/live/$1"; }

check_deps() {
  local need=()
  have curl    || need+=(curl)
  have openssl || need+=(openssl)
  have certbot || need+=(certbot)
  if ((${#need[@]})); then
    echo "[*] Installing dependencies: ${need[*]}"
    apt update
    apt install -y curl openssl certbot python3-certbot-dns-cloudflare
  fi
}

# ---------- Cloudflare helpers ----------
_cf_read_token() {
  [[ -r "$CF_CREDS" ]] || return 2
  local t
  t="$(grep -E '^\s*dns_cloudflare_api_token\s*=' "$CF_CREDS" 2>/dev/null | sed 's/.*=\s*//')"
  [[ -n "$t" ]] || return 2
  printf '%s' "$t"
}

_cf_find_zone() {
  local dom="$1" token; token="$(_cf_read_token)" || return 2
  local candidate="$dom" resp id
  while [[ "$candidate" == *.* ]]; do
    resp="$(curl -fsS -H "Authorization: Bearer ${token}" -H "Content-Type: application/json" \
      "https://api.cloudflare.com/client/v4/zones?name=${candidate}&status=active" 2>/dev/null || true)"
    [[ -n "$resp" ]] || return 3
    if grep -q '"success":true' <<<"$resp" && grep -q "\"name\":\"${candidate}\"" <<<"$resp"; then
      id="$(grep -o '"id":"[a-f0-9]\{32\}"' <<<"$resp" | head -n1 | cut -d'"' -f4)"
      [[ -n "$id" ]] && { echo "${candidate} ${id}"; return 0; }
    fi
    candidate="${candidate#*.}"
  done
  return 1
}

# ---------- Certbot helpers ----------
_check_existing_cert() {
  local dom="$1" lin; lin="$(lineage_path "$dom")"
  if [[ -f "${lin}/cert.pem" ]]; then
    local exp; exp=$(openssl x509 -enddate -noout -in "${lin}/cert.pem" 2>/dev/null | cut -d= -f2 || echo "unknown")
    echo "[!] A certificate already exists for '${dom}'"
    echo "    Path: ${lin}"
    echo "    Expires: ${exp}"
    return 0
  fi
  return 1
}

_patch_renewal_files_ps() {
  local ps="${CFG_PROPAGATION_SECONDS:-$DEFAULT_PROPAGATION}"
  [[ -z "$ps" || "$ps" == "0" ]] && ps="$DEFAULT_PROPAGATION"
  shopt -s nullglob
  for f in /etc/letsencrypt/renewal/*.conf; do
    grep -q '^\s*authenticator\s*=\s*dns-cloudflare' "$f" || continue
    if grep -q '^\s*dns_cloudflare_propagation_seconds\s*=' "$f"; then
      sed -i "s/^\s*dns_cloudflare_propagation_seconds\s*=.*/dns_cloudflare_propagation_seconds = ${ps}/" "$f"
    else
      echo "dns_cloudflare_propagation_seconds = ${ps}" >> "$f"
    fi
  done
  shopt -u nullglob
}

# ---------- Install / Setup ----------
cmd_install() { ensure_root; ensure_paths; check_deps; echo "[*] Dependencies installed/verified."; }

_setup_status() {
  read_conf
  local em_ok=no cf_ok=no

  # email is OK only if set and passes the validator
  if [[ -n "${CFG_EMAIL:-}" ]] && _valid_email "${CFG_EMAIL}"; then
    em_ok=yes
  fi

  # CF token OK if the creds file exists and contains a token
  if _cf_read_token >/dev/null 2>&1; then
    cf_ok=yes
  fi

  echo "$em_ok $cf_ok"
}

cmd_setup() {
  ensure_root; ensure_paths; check_deps
  read_conf
  read -r EM_OK CF_OK < <(_setup_status)

  # If fully configured, offer to skip
  if [[ "$EM_OK" == "yes" && "$CF_OK" == "yes" ]]; then
    echo "[*] Already configured:"
    echo "    - Email: ${CFG_EMAIL}"
    echo "    - CF token: present"
    read -rp "Reconfigure email/token? (y/N): " ans || true
    [[ "${ans,,}" == "y" ]] || { echo "[*] Leaving setup unchanged."; return 0; }
  fi

  # Email (placeholder shown; keep existing if user presses Enter and one exists)
  local email="${CFG_EMAIL:-}"
  while true; do
    if [[ -n "$email" ]]; then
      read -rp "Let's Encrypt email (e.g., example@gmail.com) [leave blank to keep current]: " in || true
      [[ -n "$in" ]] && email="$in"
      _valid_email "$email" && break
      echo "Invalid email format, try again."
    else
      read -rp "Let's Encrypt email (e.g., example@gmail.com): " in || true
      [[ -n "$in" ]] && email="$in"
      _valid_email "$email" && break
      echo "Invalid email format, try again."
    fi
  done
  sed -i "s|^email=.*|email=${email}|" "$MAIN_CONF"

  # CF token (blank = keep current if present, or just skip silently)
  local had_token="no"; _cf_read_token >/dev/null 2>&1 && had_token="yes"
  read -rp "Cloudflare API token (leave empty to keep current/skip): " token || true
  if [[ -n "$token" ]]; then
    mkdir -p "$(dirname "$CF_CREDS")"
    printf 'dns_cloudflare_api_token = %s\n' "$token" > "$CF_CREDS"
    chmod 600 "$CF_CREDS"
    echo "[*] Saved token to ${CF_CREDS}"
  fi

  systemctl enable --now certbot.timer || true

  # Ensure deploy hook exists
  local hook="/usr/local/bin/${APP}-deploy"
  cat >"$hook" <<'EOF'
#!/usr/bin/env bash
set -Eeuo pipefail
APP="smart-ssl"
CONF_DIR="/etc/${APP}"
DOM_DIR="${CONF_DIR}/domains"
BIN="/usr/local/bin/${APP}"
shopt -s nullglob
for conf in "${DOM_DIR}"/*.conf; do
  dom=$(grep '^domain=' "$conf" | cut -d= -f2)
  [[ -n "$dom" ]] && "${BIN}" publish "$dom" || true
done
shopt -u nullglob
EOF
  chmod 0755 "$hook"
  mkdir -p /etc/letsencrypt/renewal-hooks/deploy
  ln -sfn "$hook" "/etc/letsencrypt/renewal-hooks/deploy/99-${APP}-deploy"

  echo "[*] Setup complete:"
  echo "    - Email: ${email}"
  if _cf_read_token >/dev/null 2>&1; then
    echo "    - CF token: configured"
  else
    echo "    - CF token: not set"
  fi
  echo "    - Auto-renew: enabled (certbot.timer)"
}

cmd_rotate_token() {
  ensure_root; ensure_paths
  read -rp "New Cloudflare API token: " token
  [[ -n "$token" ]] || { echo "[!] Empty token; nothing changed."; return 0; }
  mkdir -p "$(dirname "$CF_CREDS")"
  printf 'dns_cloudflare_api_token = %s\n' "$token" > "$CF_CREDS"
  chmod 600 "$CF_CREDS"
  echo "[*] Updated token at ${CF_CREDS}"
}

# ---------- Issue (Cloudflare) ----------
_issue_cert_cf() {
  local dom="$1" mode="$2" pub="$3"
  read_conf

  if _cf_find_zone "$dom" >/dev/null; then
    echo "[*] Cloudflare zone access OK."
  else
    case $? in
      1) echo "[!] '${dom}' (or parent) not in your Cloudflare account."; return 1;;
      2) echo "[!] Cloudflare token not found at ${CF_CREDS}. Configure in option 2."; return 1;;
      3) echo "[!] Cloudflare API query failed (token/permissions/network)."; return 1;;
      *) echo "[!] Unknown Cloudflare check error."; return 1;;
    esac
  fi

  local force_flag=""
  [[ -d "/etc/letsencrypt/live/${dom}" ]] && force_flag="--force-renewal"

  local -a dargs
  if [[ "$mode" == "wildcard" ]]; then dargs=(-d "$dom" -d "*.$dom"); else dargs=(-d "$dom"); fi
  local ps="${CFG_PROPAGATION_SECONDS:-$DEFAULT_PROPAGATION}"; [[ -z "$ps" || "$ps" == "0" ]] && ps="$DEFAULT_PROPAGATION"

  certbot certonly \
    --dns-cloudflare \
    --dns-cloudflare-credentials "$CF_CREDS" \
    --dns-cloudflare-propagation-seconds "$ps" \
    "${dargs[@]}" \
    -m "${CFG_EMAIL}" --agree-tos --no-eff-email --non-interactive \
    $force_flag || return 1

  cat >"$(domain_conf_path "$dom")" <<EOF
domain=${dom}
mode=${mode}
publish_path=${pub}
method=cloudflare
EOF
  [[ -n "$pub" ]] && cmd_publish "$dom" || echo "[*] Issued (LE live path)."
}

cmd_add_cf() {
  ensure_root; ensure_paths; read_conf; check_deps
  local dom mode pub
  read -rp "Domain (example.com or vpn.example.com): " dom
  _valid_domain "$dom" || { echo "[!] Invalid domain."; return 0; }
  read -rp "Mode (simple|wildcard) [simple]: " mode; mode="${mode:-simple}"
  [[ "$mode" == "simple" || "$mode" == "wildcard" ]] || mode="simple"
  read -rp "Publish path (empty=use LE path only): " pub

  if _check_existing_cert "$dom"; then
    read -rp "Force re-issue anyway? (y/N): " ans
    [[ "${ans,,}" == "y" ]] || { echo "[*] Skipped issuing for ${dom}."; return 0; }
  fi
  _issue_cert_cf "$dom" "$mode" "$pub" || echo "[!] Issue failed."
}

# ---------- Issue (Standard Certbot) ----------
_issue_cert_std() {
  local dom="$1" challenge="$2" webroot="$3" pub="$4"
  read_conf
  local force_flag=""
  [[ -d "/etc/letsencrypt/live/${dom}" ]] && force_flag="--force-renewal"

  local -a extra=()
  if [[ "$challenge" == "webroot" ]]; then
    [[ -d "$webroot" ]] || { echo "[!] Webroot does not exist: $webroot"; return 1; }
    extra=(--webroot -w "$webroot")
  else
    extra=(--standalone)
  fi

  certbot certonly "${extra[@]}" -d "$dom" \
    -m "${CFG_EMAIL}" --agree-tos --no-eff-email --non-interactive $force_flag || return 1

  cat >"$(domain_conf_path "$dom")" <<EOF
domain=${dom}
mode=simple
publish_path=${pub}
method=standard
EOF
  [[ -n "$pub" ]] && cmd_publish "$dom" || echo "[*] Issued (LE live path)."
}

cmd_add_std() {
  ensure_root; ensure_paths; read_conf; check_deps
  local dom ch webroot pub
  read -rp "Domain (no wildcards): " dom
  _valid_domain "$dom" || { echo "[!] Invalid domain."; return 0; }
  read -rp "Challenge (standalone|webroot) [standalone]: " ch; ch="${ch:-standalone}"
  [[ "$ch" == "webroot" ]] && read -rp "Webroot path (e.g. /var/www/html): " webroot
  read -rp "Publish path (empty=use LE path only): " pub

  if _check_existing_cert "$dom"; then
    read -rp "Force re-issue anyway? (y/N): " ans
    [[ "${ans,,}" == "y" ]] || { echo "[*] Skipped issuing for ${dom}."; return 0; }
  fi
  _issue_cert_std "$dom" "$ch" "${webroot:-}" "$pub" || echo "[!] Issue failed."
}

# ---------- Publish ----------
cmd_publish() {
  ensure_root; ensure_paths
  local dom="${1:-}"; [[ -n "$dom" ]] || { echo "[!] Usage: ${APP} publish <domain>"; return 0; }
  local conf; conf="$(domain_conf_path "$dom")"; [[ -f "$conf" ]] || { echo "[!] No config for ${dom}"; return 0; }
  # shellcheck disable=SC1090
  source "$conf"
  local lineage="/etc/letsencrypt/live/${domain}"
  [[ -d "$lineage" ]] || { echo "[!] No LE lineage at ${lineage}"; return 0; }

  if [[ -z "${publish_path}" ]]; then
    echo "[*] No publish path set; nothing to do."
    return 0
  fi

  # Normalize path (trim spaces; add trailing slash for clarity)
  publish_path="$(echo -n "$publish_path" | sed 's:[[:space:]]\+$::')"
  [[ "${publish_path}" == */ ]] || publish_path="${publish_path}/"

  mkdir -p "${publish_path}"

  # Copy files (not move) so LE stays canonical; set safe perms
  install -m "${DEFAULT_KEY_MODE}"  "${lineage}/privkey.pem"   "${publish_path}privkey.pem"
  install -m "${DEFAULT_CERT_MODE}" "${lineage}/fullchain.pem" "${publish_path}fullchain.pem"

  # Provide chain.pem when available
  cp -f "${lineage}/chain.pem" "${publish_path}chain.pem" 2>/dev/null || true

  # Also write a real Marzban-friendly key file: key.pem (copy, not symlink)
  install -m "${DEFAULT_KEY_MODE}" "${lineage}/privkey.pem" "${publish_path}key.pem"

  echo "[*] Published ${domain} → ${publish_path}"
  echo "    (Tip: using a trailing '/' in paths is recommended, e.g. /var/lib/marzban/certs/)"
}

# ---------- Selectors ----------
_select_domain_from_list() {
  # build a safe list of domain config files
  shopt -s nullglob
  local files=( "${DOM_DIR}"/*.conf )
  shopt -u nullglob

  # no managed domains -> return to caller
  if (( ${#files[@]} == 0 )); then
    echo "(no managed domains yet)" >&2
    return 1
  fi

  echo "Select a domain:" >&2
  local i=1 d
  for f in "${files[@]}"; do
    d="$(grep -E '^domain=' "$f" 2>/dev/null | cut -d= -f2)"
    [[ -n "$d" ]] || continue
    printf "  %d) %s\n" "$i" "$d" >&2
    ((i++))
  done

  # if nothing printable was found, bail out
  if (( i == 1 )); then
    echo "(no managed domains yet)" >&2
    return 1
  fi

  echo "  0) Cancel" >&2
  local choice
  while true; do
    read -rp "Enter number: " choice
    [[ "$choice" =~ ^[0-9]+$ ]] || { echo "Enter a number." >&2; continue; }
    (( choice>=0 && choice< i )) || { echo "Out of range." >&2; continue; }
    break
  done
  (( choice == 0 )) && { echo "Cancelled." >&2; return 1; }

  printf '%s\n' "${files[$((choice-1))]}"
}

_pick_from_array() {
  local varname="$1"; shift || true
  local arr=()
  eval "arr=(\"\${${varname}[@]}\" )"
  local n=${#arr[@]}
  (( n > 0 )) || { echo "(none)" >&2; return 1; }
  echo "Select an item:" >&2
  local i=1
  for x in "${arr[@]}"; do
    printf "  %d) %s\n" "$i" "$x" >&2
    ((i++))
  done
  echo "  0) Cancel" >&2
  local choice
  while true; do
    read -rp "Enter number: " choice
    [[ "$choice" =~ ^[0-9]+$ ]] || { echo "Enter a number." >&2; continue; }
    (( choice>=0 && choice<=n )) || { echo "Out of range." >&2; continue; }
    break
  done
  (( choice==0 )) && { echo "Cancelled." >&2; return 1; }
  printf '%s\n' "${arr[$((choice-1))]}"
}

# ---------- List / Change publish / Remove / Dry-run ----------
cmd_list() {
  ensure_paths
  shopt -s nullglob
  local any=0
  for f in "${DOM_DIR}"/*.conf; do
    any=1
    local d pub mode lineage exp
    d=$(grep '^domain=' "$f" | cut -d= -f2)
    pub=$(grep '^publish_path=' "$f" | cut -d= -f2)
    mode=$(grep '^mode=' "$f" | cut -d= -f2)
    lineage="/etc/letsencrypt/live/${d}"
    exp="n/a"
    if [[ -f "${lineage}/cert.pem" ]]; then
      exp=$(openssl x509 -enddate -noout -in "${lineage}/cert.pem" 2>/dev/null | cut -d= -f2 || echo "n/a")
    fi
    printf -- "- %-30s [%s]  publish: %-22s  expires: %s\n" "$d" "$mode" "${pub:-<LE path>}" "$exp"
  done
  shopt -u nullglob
  (( any == 0 )) && echo "(no managed domains yet)"
  return 0
}

cmd_change_publish() {
  ensure_root; ensure_paths
  local file; file="$(_select_domain_from_list)" || return 0
  local dom curr
  dom=$(grep '^domain=' "$file" | cut -d= -f2)
  curr=$(grep '^publish_path=' "$file" | cut -d= -f2)

  # Show a hint so users add the trailing slash
  echo "Hint: end directories with '/' (e.g. /var/lib/marzban/certs/)"
  read -rp "New publish path for '${dom}' (empty=use LE path only) [${curr}]: " np
  np="${np:-$curr}"
  np="$(echo -n "$np" | sed 's:[[:space:]]\+$::')"
  [[ -n "$np" && "${np}" != */ ]] && np="${np}/"

  sed -i "s|^publish_path=.*|publish_path=${np}|" "$file"

  echo "[*] Publishing to new path…"
  if cmd_publish "$dom"; then
    if [[ -n "$curr" && -n "$np" && "$curr" != "$np" && -d "$curr" ]]; then
      echo "[*] Old path detected: ${curr}"
      read -rp "Remove old copied certs in '${curr}' (privkey.pem/key.pem/fullchain.pem/chain.pem)? (y/N): " rmold
      if [[ "${rmold,,}" == "y" ]]; then
        rm -f "${curr%/}/privkey.pem" "${curr%/}/key.pem" "${curr%/}/fullchain.pem" "${curr%/}/chain.pem" 2>/dev/null || true
        echo "[*] Old files removed from ${curr}"
      fi
    fi
  else
    echo "[!] Publish failed; path updated in config but no files were copied."
  fi
}


cmd_remove() {
  ensure_root; ensure_paths
  local file; file="$(_select_domain_from_list)" || return 0
  local dom; dom=$(grep '^domain=' "$file" | cut -d= -f2)
  read -rp "Also delete Let's Encrypt cert for '${dom}'? (y/N): " ans
  if [[ "${ans,,}" == "y" ]]; then
    echo "[*] Deleting certbot lineage for ${dom}…"
    certbot delete --cert-name "$dom" --non-interactive || true
    rm -f "/etc/letsencrypt/renewal/${dom}.conf" 2>/dev/null || true
  fi
  rm -f "$file"
  echo "[*] Removed domain '${dom}'."
}

cmd_manual_renew() {
  ensure_root; ensure_paths; read_conf
  echo "[*] Ensuring CF propagation seconds in renewal files: ${CFG_PROPAGATION_SECONDS:-$DEFAULT_PROPAGATION}s"
  _patch_renewal_files_ps
  echo "[*] Running dry-run for managed domains only…"
  shopt -s nullglob
  for f in "${DOM_DIR}"/*.conf; do
    local d; d=$(grep '^domain=' "$f" | cut -d= -f2)
    [[ -n "$d" && -d "/etc/letsencrypt/live/${d}" ]] || continue
    echo "---- Dry-run: ${d} ----"
    certbot renew --dry-run --cert-name "${d}" || true
  done
  shopt -u nullglob
}

# ---------- Migration ----------
_list_lineages_real() {
  shopt -s nullglob
  local out=()
  for d in /etc/letsencrypt/live/*; do
    [[ -d "$d" ]] || continue
    [[ -f "$d/cert.pem" ]] || continue
    out+=("$(basename "$d")")
  done
  printf '%s\n' "${out[@]}" | sort -u
  shopt -u nullglob
}

_domains_from_renewal() {
  local nm="${1:-}"
  local rf="/etc/letsencrypt/renewal/${nm}.conf"
  [[ -n "$nm" && -f "$rf" ]] || { echo ""; return 0; }
  grep -E '^\s*domains\s*=' "$rf" | sed 's/^[^=]*=\s*//' | tr ',' ' ' | tr -s ' ' || true
}

_domains_from_live_cert() {
  # Read DNS names (SANs) from the live certificate
  local nm="${1:-}"
  local cert="/etc/letsencrypt/live/${nm}/cert.pem"
  [[ -f "$cert" ]] || { echo ""; return 0; }

  # Extract SANs robustly; output space-separated list of DNS names
  local sans
  sans="$(openssl x509 -noout -text -in "$cert" 2>/dev/null \
        | awk '/Subject Alternative Name/{flag=1; next} /X509v3/{flag=0} flag' \
        | tr -d ' ' | tr ',' '\n' | sed -n 's/^DNS://p' \
        | tr '\n' ' ' | sed 's/[[:space:]]\+$//')"
  echo "${sans}"
}

cmd_import_existing() {
  ensure_root; ensure_paths
  mapfile -t LINS < <(_list_lineages_real)
  (( ${#LINS[@]} )) || { echo "(no real certbot lineages found)"; return 0; }

  shopt -s nullglob
  mapfile -t managed < <(grep -h '^domain=' "${DOM_DIR}"/*.conf 2>/dev/null | cut -d= -f2 || true)
  shopt -u nullglob
  declare -A seen=(); for d in "${managed[@]}"; do seen["$d"]=1; done
  CANDS=(); for lin in "${LINS[@]}"; do [[ -n "${seen[$lin]:-}" ]] || CANDS+=("$lin"); done
  (( ${#CANDS[@]} )) || { echo "(nothing to import)"; return 0; }

  local pick; pick="$(_pick_from_array CANDS)" || return 0
  local pub=""; read -rp "Publish path for '${pick}' (empty=use LE path only): " pub

  cat >"$(domain_conf_path "$pick")" <<EOF
domain=${pick}
mode=simple
publish_path=${pub}
method=imported
EOF

  [[ -n "$pub" ]] && cmd_publish "$pick" || echo "[*] Imported '${pick}' (no publish path set)."
  echo "[*] Future renewals will auto-publish via deploy hook."
}

cmd_convert_to_cf() {
  ensure_root; ensure_paths; read_conf; check_deps
  if [[ ! -r "$CF_CREDS" ]]; then
    echo "[!] Cloudflare token file not found at ${CF_CREDS}."
    echo "    Please configure Cloudflare first via option 2 (Setup)."
    return 0
  fi

  mapfile -t LINS < <(_list_lineages_real)
  (( ${#LINS[@]} )) || { echo "(no real certbot lineages)"; return 0; }

  local pick; pick="$(_pick_from_array LINS)" || { echo "Cancelled."; return 0; }

  # Try renewal file first, then fall back to SANs in the live cert
  local names
  names="$(_domains_from_renewal "$pick" 2>/dev/null)"
  if [[ -z "$names" ]]; then
    echo "[*] Renewal file missing domains; using SANs from live certificate…"
    names="$(_domains_from_live_cert "$pick")"
  fi
  if [[ -z "$names" ]]; then
    echo "[!] Could not determine domain list for '${pick}' from renewal file or live certificate."
    echo "    Ensure the certificate exists at /etc/letsencrypt/live/${pick}/cert.pem, or import via option 10."
    return 0
  fi

  # Build -d args from names
  local -a dargs=()
  local n
  for n in $names; do
    dargs+=(-d "$n")
  done

  # Ensure propagation seconds has a safe default
  local ps="${CFG_PROPAGATION_SECONDS:-$DEFAULT_PROPAGATION}"
  [[ -z "${ps:-}" || "$ps" == "0" ]] && ps="$DEFAULT_PROPAGATION"

  echo "[*] Reissuing '${pick}' with Cloudflare DNS (propagation ${ps}s)…"
  set +e
  certbot certonly \
    --dns-cloudflare \
    --dns-cloudflare-credentials "$CF_CREDS" \
    --dns-cloudflare-propagation-seconds "$ps" \
    --cert-name "$pick" \
    ${dargs[@]+"${dargs[@]}"} \
    -m "${CFG_EMAIL}" --agree-tos --no-eff-email --non-interactive \
    --force-renewal
  local rc=$?
  set -e
  if (( rc != 0 )); then
    echo "[!] Reissue failed (exit $rc)."
    return 0
  fi

  echo "[*] Converted '${pick}' to Cloudflare DNS."
  if [[ -f "$(domain_conf_path "$pick")" ]]; then
    cmd_publish "$pick" || true
  fi
}

# ---------- Self-update / Uninstall ----------
cmd_self_update() {
  ensure_root
  local tmp; tmp="$(mktemp)"
  local url="${SMARTSSL_RAW_BASE}/smart-ssl"
  echo "[*] Fetching latest Smart-SSL from: ${url}"
  if ! curl -fsSL "$url" -o "$tmp"; then rm -f "$tmp"; echo "[!] Download failed."; return 0; fi
  grep -q '^APP="smart-ssl"$' "$tmp" || { rm -f "$tmp"; echo "[!] Downloaded file doesn't look like smart-ssl."; return 0; }
  install -m 0755 "$tmp" "$SMARTSSL_BIN"
  rm -f "$tmp"
  echo "[*] Updated. Restarting Smart-SSL…"
  exec "$SMARTSSL_BIN" menu
}

cmd_uninstall() {
  ensure_root
  echo "This will remove Smart-SSL from this server."
  echo " - Binary: ${SMARTSSL_BIN}"
  echo " - Config dir: ${CONF_DIR}"
  echo " - Cloudflare token file: ${CF_CREDS}"
  echo " - Deploy hook (renewal copy)"
  echo "It will NOT delete Let's Encrypt certificates unless you confirm."
  read -rp "Proceed? (y/N): " ans
  [[ "${ans,,}" == "y" ]] || { echo "Aborted."; return 0; }

  set +e
  echo "[*] Removing deploy hook…"
  rm -f "/etc/letsencrypt/renewal-hooks/deploy/99-${APP}-deploy" 2>/dev/null
  rm -f "/usr/local/bin/${APP}-deploy" 2>/dev/null

  echo "[*] Collecting managed domains…"
  shopt -s nullglob
  conf_files=( "${DOM_DIR}"/*.conf )
  shopt -u nullglob

  _doms=()
  if ((${#conf_files[@]})); then
    mapfile -t _doms < <(grep -h '^domain=' "${conf_files[@]}" 2>/dev/null | cut -d= -f2)
  fi
  echo "    Found: ${#_doms[@]} domain(s)"

  # --- NEW: collect publish paths and offer to remove copied certs there ---
  pubpaths=()
  if ((${#conf_files[@]})); then
    while IFS='=' read -r k v; do
      [[ "$k" == "publish_path" && -n "$v" ]] || continue
      # normalize (trim trailing spaces, ensure trailing slash)
      v="$(echo -n "$v" | sed 's:[[:space:]]\+$::')"
      [[ "$v" == */ ]] || v="${v}/"
      pubpaths+=("$v")
    done < <(grep -h '^publish_path=' "${conf_files[@]}" 2>/dev/null)
  fi
  # dedupe
  if ((${#pubpaths[@]})); then
    mapfile -t pubpaths < <(printf '%s\n' "${pubpaths[@]}" | awk '!seen[$0]++')
  fi

  if ((${#pubpaths[@]})); then
    echo "[*] Publish paths detected:"
    printf '    - %s\n' "${pubpaths[@]}"
    read -rp "Remove copied cert files from these paths (privkey.pem, key.pem, fullchain.pem, chain.pem)? (y/N): " rm_pub
    if [[ "${rm_pub,,}" == "y" ]]; then
      for p in "${pubpaths[@]}"; do
        rm -f "${p%/}/privkey.pem" "${p%/}/key.pem" "${p%/}/fullchain.pem" "${p%/}/chain.pem" 2>/dev/null || true
      done
      echo "[*] Removed copied cert files from publish paths."
    fi
  fi
  # --- end NEW ---

  echo "[*] Removing Smart-SSL config directory…"
  rm -rf "$CONF_DIR" 2>/dev/null

  echo "[*] Removing Cloudflare token file (if present)…"
  rm -f "$CF_CREDS" 2>/dev/null

  if ((${#_doms[@]})); then
    read -rp "Also delete Let's Encrypt certificates for: ${_doms[*]} ? (y/N): " purge
    if [[ "${purge,,}" == "y" ]]; then
      for d in "${_doms[@]}"; do
        [[ -n "$d" ]] || continue
        echo "   - Deleting certbot lineage for ${d}…"
        certbot delete --cert-name "$d" --non-interactive || true
        rm -f "/etc/letsencrypt/renewal/${d}.conf" 2>/dev/null || true
      done
    fi
  fi

  # Orphan lineages (not managed by Smart-SSL), e.g., *-staging
  shopt -s nullglob
  mapfile -t all_lins < <(for d in /etc/letsencrypt/live/*; do [[ -f "$d/cert.pem" ]] && basename "$d"; done)
  shopt -u nullglob

  declare -A managed_set=()
  for d in "${_doms[@]}"; do managed_set["$d"]=1; done

  orphans=()
  for lin in "${all_lins[@]}"; do
    [[ -z "${managed_set[$lin]:-}" ]] && orphans+=("$lin")
  done

  if ((${#orphans[@]})); then
    echo "[*] Orphaned Let's Encrypt lineages (not managed by Smart-SSL): ${orphans[*]}"
    read -rp "Delete these as well (including any *-staging)? (y/N): " del_orphans
    if [[ "${del_orphans,,}" == "y" ]]; then
      for o in "${orphans[@]}"; do
        echo "   - Deleting lineage ${o}…"
        certbot delete --cert-name "$o" --non-interactive || true
        rm -f "/etc/letsencrypt/renewal/${o}.conf" 2>/dev/null || true
        rm -rf "/etc/letsencrypt/live/${o}" "/etc/letsencrypt/archive/${o}" 2>/dev/null || true
      done
    fi
  fi

  echo "[*] Removing Smart-SSL binary…"
  rm -f "$SMARTSSL_BIN" 2>/dev/null
  echo "[*] Uninstalled. (Exiting.)"
  exit 0
}

# ---------- UI Colors (safe for light & dark) ----------
init_colors() {
  # Optional: SMARTSSL_THEME=light|dark|auto (default: auto)
  local theme="${SMARTSSL_THEME:-auto}"

  local supports_color=0
  if [ -t 1 ] && command -v tput >/dev/null 2>&1; then
    if [ "$(tput colors 2>/dev/null || echo 0)" -ge 8 ]; then
      supports_color=1
    fi
  fi

  if [[ $supports_color -eq 1 ]]; then
    # Universal-safe defaults that look good on light & dark
    BORD="\e[1;37m"   # bold white border
    NUM="\e[36m"      # cyan numbers
    TITLE="\e[36m"    # cyan title
    RESET="\e[0m"
    GOOD="\e[32m"     # green
    BAD="\e[31m"      # red
    WARN="\e[33m"     # yellow

    # Allow theme override
    case "$theme" in
      light)
        BORD="\e[1;30m"   # bold black/gray
        NUM="\e[36m"
        TITLE="\e[30m"
        ;;
      dark)
        BORD="\e[1;37m"
        NUM="\e[36m"
        TITLE="\e[36m"
        ;;
      *) : ;;
    esac
  else
    BORD=""; NUM=""; TITLE=""; RESET=""; GOOD=""; BAD=""; WARN=""
  fi
}

_setup_brief_status() {
  read -r EM_OK CF_OK < <(_setup_status)
  local em icon_setup icon_cf
  [[ "$EM_OK" == "yes" ]] && icon_setup="${GOOD}✅${RESET}" || icon_setup="${BAD}❌${RESET}"
  [[ "$CF_OK" == "yes" ]] && icon_cf="${GOOD}✅${RESET}" || icon_cf="${WARN}⚠${RESET}"
  em="${CFG_EMAIL:-not set}"
  echo -e "   Email: ${em}   CF token: ${icon_cf}   Setup: ${icon_setup}"
}

# ---------- Menu ----------
menu() {
  ensure_root
  ensure_paths
  read_conf
  init_colors

  # How many blank lines between menu items (0 = none, 1 = one line, etc.)
  local LINE_GAP=1

  # ---------- inline helpers ----------
  _rep() {  # repeat char n times
    local c="$1" n="$2"
    printf "%*s" "$n" "" | tr ' ' "$c"
  }

  _wrap() {  # _wrap "text" width indent
    local text="$1" width="$2" indent="$3"
    if command -v fold >/dev/null 2>&1; then
      printf "%s\n" "$text" | fold -s -w "$width" | sed "2,\$s/^/${indent}/"
    else
      awk -v w="$width" -v ind="$indent" '
        {
          line="";
          for (i=1;i<=NF;i++) {
            if (length(line $i) + (line==""?0:1) > w) {
              print line;
              line=$i;
            } else {
              line=(line==""?$i:line" "$i);
            }
          }
          print line;
        }' <<<"$text" | sed "2,\$s/^/${indent}/"
    fi
  }

  # spacer rows between items; mode: 0=wide/table, 1=compact
  _gap_rows() {
    local n="$1" mode="$2" w1="$3" w2="$4" g
    for ((g=0; g<n; g++)); do
      if (( mode == 0 )); then
        printf "| %-${w1}s | %-${w2}s |\n" "" ""
      else
        echo
      fi
    done
  }

  while true; do
    clear
    echo -e "${TITLE}Smart-SSL v${VERSION}${RESET}"
    echo -e "${BORD}=========================================${RESET}"
    _setup_brief_status
    echo

    # Menu entries: "No|Label"
    local items=(
      "1|Install dependencies"
      "2|Setup (email + Cloudflare token + enable auto-renew)"
      "3|Add certificate (Cloudflare DNS)"
      "4|Add certificate (Standard Certbot: standalone/webroot)"
      "5|List managed domains"
      "6|Change publish path & publish now"
      "7|Manual renew / dry-run (managed domains only)"
      "8|Rotate Cloudflare token"
      "9|Remove a domain"
      "10|Import existing Certbot certificate (adopt)"
      "11|Convert existing Certbot cert to Cloudflare DNS"
      "12|Self-update Smart-SSL"
      "13|Uninstall Smart-SSL"
      "0|Exit"
    )

    # Sizing & mode
    local cols; cols=$(tput cols 2>/dev/null || echo 80)
    (( cols < 40 )) && cols=40
    local compact=0
    if (( cols < 72 )); then compact=1; fi

    if (( compact == 0 )); then
      # ---------- WIDE MODE: ASCII table ----------
      local w1=4
      local w2=$(( cols - 7 - w1 ))   # borders & spaces add up to 7
      (( w2 < 40 )) && w2=40

      # Top border
      printf "+%s+%s+\n" "$(_rep '-' $((w1+2)))" "$(_rep '-' $((w2+2)))"
      # Header
      printf "| %-*s | %-*s |\n" "$w1" "No." "$w2" "Action"
      # Mid border
      printf "+%s+%s+\n" "$(_rep '-' $((w1+2)))" "$(_rep '-' $((w2+2)))"

      local i it num label pad
      for ((i=0; i<${#items[@]}; i++)); do
        it="${items[i]}"
        num="${it%%|*}"
        label="${it#*|}"
        pad=$(( w1 - ${#num} )); (( pad < 0 )) && pad=0

        # number cell: pre-pad spaces, then colored number via %b
        printf "| %*s%b | %-*.*s |\n" \
          "$pad" "" "${NUM}${num}${RESET}" "$w2" "$w2" "$label"

        # vertical spacing except after the last item
        if (( i < ${#items[@]} - 1 )); then
          _gap_rows "$LINE_GAP" 0 "$w1" "$w2"
        fi
      done
      # Bottom border
      printf "+%s+%s+\n" "$(_rep '-' $((w1+2)))" "$(_rep '-' $((w2+2)))"

    else
      # ---------- COMPACT MODE: mobile-friendly list ----------
      echo "No.  Action"
      echo "---- ----------------------------------------------------------------"
      local i it num label indent width
      width=$(( cols - 6 )); (( width < 20 )) && width=20
      for ((i=0; i<${#items[@]}; i++)); do
        it="${items[i]}"
        num="${it%%|*}"
        label="${it#*|}"
        indent="     "  # 5 spaces after "N) "

        printf "%b) " "${NUM}${num}${RESET}"
        _wrap "$label" "$width" "$indent"

        if (( i < ${#items[@]} - 1 )); then
          _gap_rows "$LINE_GAP" 1 0 0
        fi
      done
      echo "---- ----------------------------------------------------------------"
    fi

    echo
    read -rp "Select an option: " choice
    echo

    case "$choice" in
      1)  cmd_install; pause ;;
      2)  cmd_setup; pause ;;
      3)  cmd_add_cf; pause ;;
      4)  cmd_add_std; pause ;;
      5)  cmd_list; pause ;;
      6)  cmd_change_publish; pause ;;
      7)  cmd_manual_renew; pause ;;
      8)  cmd_rotate_token; pause ;;
      9)  cmd_remove; pause ;;
      10) cmd_import_existing; pause ;;
      11) cmd_convert_to_cf; pause ;;
      12) cmd_self_update ;;   # restarts into new version
      13) cmd_uninstall ;;     # exits
      0|q|Q) clear; exit 0 ;;
      *)  echo "Invalid option"; sleep 1 ;;
    esac
  done
}
# ---------- Dispatcher ----------
case "${1:-}" in
  menu|'') menu ;;
  install) cmd_install ;;
  setup) cmd_setup ;;
  add-cf) cmd_add_cf ;;
  add-std) cmd_add_std ;;
  list) cmd_list ;;
  publish) shift; cmd_publish "${1:-}" ;;
  change-publish) cmd_change_publish ;;
  manual-renew) cmd_manual_renew ;;
  rotate-token) cmd_rotate_token ;;
  remove) cmd_remove ;;
  import) cmd_import_existing ;;
  convert-cf) cmd_convert_to_cf ;;
  self-update) cmd_self_update ;;
  uninstall) cmd_uninstall ;;
  version) echo "${APP} ${VERSION}" ;;
  *) echo "Usage: $APP [menu|install|setup|add-cf|add-std|list|publish <domain>|change-publish|manual-renew|rotate-token|remove|import|convert-cf|self-update|uninstall|version]";;
esac
