#!/usr/bin/env bash
set -Eeuo pipefail

APP="smart-ssl"
VERSION="0.7.0"

# --- Update source (for self-update) ---
SMARTSSL_REPO="${SMARTSSL_REPO:-Nima786/Smart-SSL}"
SMARTSSL_BRANCH="${SMARTSSL_BRANCH:-main}"
SMARTSSL_RAW_BASE="https://raw.githubusercontent.com/${SMARTSSL_REPO}/${SMARTSSL_BRANCH}"
SMARTSSL_BIN="/usr/local/bin/${APP}"

# --- Paths (system defaults, overridable via env) ---
CONF_DIR="${SMARTSSL_CONF_DIR:-/etc/${APP}}"
DOM_DIR="${CONF_DIR}/domains"
MAIN_CONF="${CONF_DIR}/config.ini"
CF_CREDS="${SMARTSSL_CREDS_PATH:-/root/.secrets/cloudflare.ini}"
TMP_DIR="${SMARTSSL_TMP_DIR:-/run/${APP}}"

# --- helpers ---
die() { echo "ERROR: $*" >&2; exit 1; }
have() { command -v "$1" >/dev/null 2>&1; }
ensure_root() { [[ ${EUID:-0} -eq 0 ]] || die "Run as root."; }

ensure_paths() {
  mkdir -p "$DOM_DIR" "$TMP_DIR"
  chmod 700 "$TMP_DIR"
  [[ -f "$MAIN_CONF" ]] || cat >"$MAIN_CONF" <<EOF
email=
propagation_seconds=90
creds=${CF_CREDS}
default_owner=root:root
default_chain_mode=copy
EOF
}

read_conf() {
  while IFS='=' read -r k v; do
    [[ "$k" =~ ^[a-z_]+$ ]] || continue
    eval "CFG_${k^^}='${v}'"
  done < <(grep -E "^[a-z_]+=" "$MAIN_CONF" || true)
}

print_usage() {
  echo "(Tip: run 'smart-ssl' with no arguments to open the interactive menu.)"
  cat <<USAGE
${APP} ${VERSION}

Commands:
  install                 Install/check dependencies
  setup                   First-time setup (email, Cloudflare token)
  add                     Issue certificate (PRODUCTION)  [prompts: domain, mode, publish path]
  add-staging             Issue certificate (STAGING / TEST; no rate limits)
  list                    List managed domains + expiry
  publish <domain>        Copy/symlink certs to custom path & run reload hooks
  enable-renew            Install deploy hook + enable certbot.timer
  rotate-token            Update Cloudflare API token
  dry-run                 Run 'certbot renew --dry-run'
  remove                  Remove a domain (select from numbered list)
  self-update             Fetch and install the latest smart-ssl from GitHub
  uninstall               Remove Smart-SSL (with prompts)
  version                 Print version
USAGE
}

check_deps() {
  local missing=()
  have certbot || missing+=("certbot")
  have openssl || missing+=("openssl")
  if ((${#missing[@]})); then
    echo "Missing deps: ${missing[*]}"
    echo "Installing..."
    apt update
    apt install -y certbot python3-certbot-dns-cloudflare openssl
  fi
  have certbot || die "certbot not installed"
}

domain_conf_path() { echo "${DOM_DIR}/$1.conf"; }
lineage_path()     { echo "/etc/letsencrypt/live/$1"; }

_valid_email() { [[ "$1" =~ ^[^@[:space:]]+@[^@[:space:]]+\.[^@[:space:]]+$ ]]; }
_valid_domain() { [[ "$1" =~ ^([a-zA-Z0-9]([-a-zA-Z0-9]*[a-zA-Z0-9])?\.)+[A-Za-z]{2,}$ ]]; }

# Parse token from the creds file used by certbot-dns-cloudflare
_cf_read_token() {
  [[ -r "$CFG_CREDS" ]] || return 2
  local t
  t="$(grep -E '^\s*dns_cloudflare_api_token\s*=' "$CFG_CREDS" 2>/dev/null | sed 's/.*=\s*//')"
  [[ -n "$t" ]] || return 2
  printf '%s' "$t"
}

# Find Cloudflare zone for a given domain using the token.
# Returns 0 and prints "zone_name zone_id" if found.
# Returns 1 if not found, 2 if token missing/bad, 3 if API error.
_cf_find_zone() {
  local dom="$1" token; token="$(_cf_read_token)" || return 2
  local candidate="$dom" resp id
  while [[ "$candidate" == *.* ]]; do
    resp="$(curl -fsS -H "Authorization: Bearer ${token}" -H "Content-Type: application/json" \
      "https://api.cloudflare.com/client/v4/zones?name=${candidate}&status=active" 2>/dev/null || true)"
    [[ -n "$resp" ]] || return 3
    if grep -q '"success":true' <<<"$resp" && grep -q "\"name\":\"${candidate}\"" <<<"$resp"; then
      id="$(grep -o '"id":"[a-f0-9]\{32\}"' <<<"$resp" | head -n1 | cut -d'"' -f4)"
      [[ -n "$id" ]] && { echo "${candidate} ${id}"; return 0; }
    fi
    candidate="${candidate#*.}"
  done
  return 1
}

_lineage_for() {
  local dom="$1" staging="${2:-0}" cn="$dom"
  [[ "$staging" == "1" ]] && cn="${dom}-staging"
  lineage_path "$cn"
}

_check_existing_cert() {
  local dom="$1" staging="${2:-0}" lin; lin="$(_lineage_for "$dom" "$staging")"
  if [[ -f "${lin}/cert.pem" ]]; then
    local exp; exp=$(openssl x509 -enddate -noout -in "${lin}/cert.pem" 2>/dev/null | cut -d= -f2 || echo "unknown")
    echo "[!] A $( [[ "$staging" == "1" ]] && echo 'staging' || echo 'production' ) certificate already exists for '${dom}'."
    echo "    Path: ${lin}"
    echo "    Expires: ${exp}"
    return 0
  fi
  return 1
}

# --- commands ---
cmd_install() {
  ensure_root; ensure_paths
  echo "[*] Installing dependencies…"
  apt update
  apt install -y certbot python3-certbot-dns-cloudflare openssl
  echo "[*] Done."
}

cmd_setup() {
  ensure_root; ensure_paths; read_conf

  local email=""
  while true; do
    read -rp "Let's Encrypt email: " email
    _valid_email "$email" && break
    echo "Invalid email format. Please try again."
  done

  read -rp "Propagation seconds [${CFG_PROPAGATION_SECONDS:-90}]: " ps
  ps="${ps:-${CFG_PROPAGATION_SECONDS:-90}}"

  mkdir -p "$(dirname "$CF_CREDS")"

  token="${SMARTSSL_CF_TOKEN:-}"
  if [[ -z "$token" ]]; then
    read -rp "Cloudflare API token (paste then ENTER): " token
    echo
  fi
  token="${token//$'\r'/}"
  [[ -n "$token" ]] || die "Token cannot be empty."

  printf 'dns_cloudflare_api_token = %s\n' "$token" > "$CF_CREDS"
  chmod 600 "$CF_CREDS"

  sed -i "s|^email=.*|email=${email}|" "$MAIN_CONF"
  sed -i "s|^propagation_seconds=.*|propagation_seconds=${ps}|" "$MAIN_CONF"
  sed -i "s|^creds=.*|creds=${CF_CREDS}|" "$MAIN_CONF"

  echo "[*] Setup complete."
}

_build_dargs() {
  local dom="$1" mode="$2"
  local -a out=()
  if [[ "$mode" == "wildcard" ]]; then
    out+=("-d" "${dom}" "-d" "*.${dom}")
  else
    out+=("-d" "${dom}")
  fi
  printf '%s\n' "${out[@]}"
}

_issue_cert() {
  local staging_flag="$1" certname_flag="$2" force_flag="$3"; shift 3
  certbot certonly \
    --dns-cloudflare \
    --dns-cloudflare-credentials "${CFG_CREDS}" \
    --dns-cloudflare-propagation-seconds "${CFG_PROPAGATION_SECONDS}" \
    "$@" \
    -m "${CFG_EMAIL}" --agree-tos --no-eff-email --non-interactive \
    ${staging_flag} ${certname_flag} ${force_flag}
}

# Simplified issuance: only Domain, Mode, Publish path; CF zone + existing cert checks; save config only on success
cmd_add_common() {
  local staging="${1:-0}"

  ensure_root; ensure_paths; read_conf; check_deps

  local dom mode pub
  read -rp "Domain (e.g., vpn.example.com or example.com): " dom
  while true; do
    if [[ -n "$dom" ]] && _valid_domain "$dom"; then break; fi
    read -rp "Invalid or empty domain. Enter a valid domain: " dom
  done

  # Cloudflare zone access check
  local zinfo zname zid
  if zinfo="$(_cf_find_zone "$dom")"; then
    read -r zname zid <<<"$zinfo"
    echo "[*] Cloudflare zone found: ${zname}"
  else
    case $? in
      1) echo "[!] Domain '${dom}' is not in your Cloudflare account (token lacks access). Add the zone in Cloudflare first."; return 1;;
      2) echo "[!] Cloudflare token not found or unreadable at ${CFG_CREDS}. Run Setup (menu 2) first."; return 1;;
      3) echo "[!] Cloudflare API query failed. Check network and token permissions."; return 1;;
      *) echo "[!] Unknown error checking Cloudflare zone."; return 1;;
    esac
  fi

  read -rp "Mode (simple|wildcard) [simple]: " mode; mode="${mode:-simple}"
  if [[ "$mode" != "simple" && "$mode" != "wildcard" ]]; then
    echo "Invalid mode; defaulting to 'simple'."; mode="simple"
  fi

  read -rp "Publish path (empty=use LE path only): " pub

  # Existing cert pre-check (production and staging)
  local force_flag=""
  if _check_existing_cert "$dom" "$staging"; then
    read -rp "Force re-issue anyway? (y/N): " ans
    [[ "${ans,,}" == "y" ]] || { echo "[*] Skipped issuing for ${dom}."; return 0; }
    force_flag="--force-renewal"
  fi

  # Build args
  mapfile -t dargs < <(_build_dargs "$dom" "$mode")
  local staging_flag="" certname_flag=""
  if [[ "$staging" == "1" ]]; then
    echo "[*] Using Let's Encrypt STAGING (test only; not trusted by browsers/clients)."
    staging_flag="--staging"
    certname_flag="--cert-name ${dom}-staging"
  fi

  # Try issuance first; only save config if success
  if _issue_cert "$staging_flag" "$certname_flag" "$force_flag" "${dargs[@]}"; then
    local owner="${CFG_DEFAULT_OWNER:-root:root}"
    local chn="${CFG_DEFAULT_CHAIN_MODE:-copy}"
    local conf_tmp="${TMP_DIR}/${dom}.conf.tmp"
    local conf_fin; conf_fin=$(domain_conf_path "$dom")

    cat >"$conf_tmp" <<EOF
domain=${dom}
mode=${mode}
sans=
publish_path=${pub}
reload_hooks=
owner=${owner}
key_mode=600
cert_mode=644
chain_mode=${chn}
EOF
    install -m 0644 "$conf_tmp" "$conf_fin"
    rm -f "$conf_tmp"

    [[ -n "$pub" ]] && cmd_publish "$dom" || echo "[*] Issued. Using LE live path."
  else
    echo "[!] Issuance failed for ${dom}. No config was saved."
    return 1
  fi
}

cmd_add()         { cmd_add_common 0; }
cmd_add_staging() { cmd_add_common 1; }

cmd_list() {
  ensure_paths
  shopt -s nullglob
  local any=0
  for f in "${DOM_DIR}"/*.conf; do
    any=1
    d=$(grep '^domain=' "$f" | cut -d= -f2)
    mode=$(grep '^mode=' "$f" | cut -d= -f2)
    pub=$(grep '^publish_path=' "$f" | cut -d= -f2)
    lineage="/etc/letsencrypt/live/${d}"
    exp="n/a"
    [[ -f "${lineage}/cert.pem" ]] && exp=$(openssl x509 -enddate -noout -in "${lineage}/cert.pem" 2>/dev/null | cut -d= -f2 || echo "n/a")
    printf -- "- %-30s [%s]  publish: %-15s  expires: %s\n" "$d" "$mode" "${pub:-<LE path>}" "$exp"
  done
  shopt -u nullglob
  (( any == 0 )) && echo "(no managed domains yet)"
}

cmd_publish() {
  ensure_root; ensure_paths
  local dom="${1:-}"; [[ -n "$dom" ]] || die "Usage: ${APP} publish <domain>"
  local conf; conf=$(domain_conf_path "$dom"); [[ -f "$conf" ]] || die "No config for ${dom}"
  # shellcheck disable=SC1090
  source <(sed 's/^/DOM_/' "$conf" | sed 's/DOM_owner/DOM_OWNER/')
  local lineage="/etc/letsencrypt/live/${DOM_domain}"
  [[ -d "$lineage" ]] || die "No LE lineage at ${lineage}. Issue cert first."

  if [[ -z "${DOM_publish_path}" ]]; then
    echo "[*] No publish path set; nothing to do."
    return 0
  fi

  mkdir -p "${DOM_publish_path}"

  if [[ "${DOM_chain_mode:-copy}" == "symlink" ]]; then
    ln -sfn "${lineage}/privkey.pem" "${DOM_publish_path}/privkey.pem"
    ln -sfn "${lineage}/fullchain.pem" "${DOM_publish_path}/fullchain.pem"
  else
    install -m "${DOM_key_mode:-600}" -o "${DOM_OWNER%:*}" -g "${DOM_OWNER#*:}" \
      "${lineage}/privkey.pem" "${DOM_publish_path}/privkey.pem"
    install -m "${DOM_cert_mode:-644}" -o "${DOM_OWNER%:*}" -g "${DOM_OWNER#*:}" \
      "${lineage}/fullchain.pem" "${DOM_publish_path}/fullchain.pem"
  fi

  IFS=',' read -ra cmds <<< "${DOM_reload_hooks}"
  for c in "${cmds[@]}"; do c=$(echo "$c" | xargs); [[ -n "$c" ]] && bash -lc "$c" || true; done
  echo "[*] Published to ${DOM_publish_path} and hooks executed."
}

cmd_enable_renew() {
  ensure_root
  local hook="/usr/local/bin/${APP}-deploy"
  cat >"$hook" <<'EOF'
#!/usr/bin/env bash
set -Eeuo pipefail
APP="smart-ssl"
CONF_DIR="/etc/${APP}"
DOM_DIR="${CONF_DIR}/domains"
BIN="/usr/local/bin/${APP}"
shopt -s nullglob
for conf in "${DOM_DIR}"/*.conf; do
  dom=$(grep '^domain=' "$conf" | cut -d= -f2)
  [[ -n "$dom" ]] && "${BIN}" publish "$dom" || true
done
shopt -u nullglob
EOF
  chmod 0755 "$hook"

  mkdir -p /etc/letsencrypt/renewal-hooks/deploy
  ln -sfn "$hook" "/etc/letsencrypt/renewal-hooks/deploy/99-${APP}-deploy"
  systemctl enable --now certbot.timer || true
  echo "[*] Auto-renew enabled with deploy hook."
}

cmd_rotate_token() {
  ensure_root; ensure_paths; read_conf
  token="${SMARTSSL_CF_TOKEN:-}"
  if [[ -z "$token" ]]; then
    read -rp "New Cloudflare API token (paste then ENTER): " token
    echo
  fi
  token="${token//$'\r'/}"
  [[ -n "$token" ]] || die "Token cannot be empty."
  printf 'dns_cloudflare_api_token = %s\n' "$token" > "$CFG_CREDS"
  chmod 600 "$CFG_CREDS"
  echo "[*] Updated token at ${CFG_CREDS}"
}

cmd_dry_run() { certbot renew --dry-run; }

# Numbered removal UI
cmd_remove() {
  ensure_root; ensure_paths
  shopt -s nullglob
  mapfile -t files < <(printf "%s\n" "${DOM_DIR}"/*.conf 2>/dev/null || true)
  shopt -u nullglob
  local n=${#files[@]}
  if (( n == 0 )); then echo "(no managed domains)"; return 0; fi

  echo "Select a domain to remove:"
  local i=1 d
  for f in "${files[@]}"; do
    d=$(grep '^domain=' "$f" | cut -d= -f2)
    printf "  %d) %s\n" "$i" "$d"
    ((i++))
  done
  echo "  0) Cancel"
  local choice
  while true; do
    read -rp "Enter number: " choice
    [[ "$choice" =~ ^[0-9]+$ ]] || { echo "Enter a number."; continue; }
    (( choice>=0 && choice<=n )) || { echo "Out of range."; continue; }
    break
  done
  (( choice == 0 )) && { echo "Cancelled."; return 0; }

  local target="${files[$((choice-1))]}"
  local dom; dom=$(grep '^domain=' "$target" | cut -d= -f2)

  read -rp "Also revoke and delete LE lineage for '${dom}'? (y/N): " ans
  if [[ "${ans,,}" == "y" ]]; then
    certbot delete --cert-name "$dom" || true
  fi
  rm -f "$target"
  echo "[*] Removed domain '${dom}'."
}

cmd_self_update() {
  ensure_root
  local tmp; tmp="$(mktemp)"
  local url="${SMARTSSL_RAW_BASE}/smart-ssl"

  echo "[*] Fetching latest Smart-SSL from: ${url}"
  if ! curl -fsSL "$url" -o "$tmp"; then
    rm -f "$tmp"; die "Download failed."
  fi
  grep -q '^APP="smart-ssl"$' "$tmp" || { rm -f "$tmp"; die "Downloaded file doesn't look like smart-ssl."; }

  echo "[*] Installing to ${SMARTSSL_BIN}"
  install -m 0755 "$tmp" "$SMARTSSL_BIN"
  rm -f "$tmp"

  echo "[*] Updated. Restarting Smart-SSL…"
  exec "$SMARTSSL_BIN" menu
}

cmd_uninstall() {
  ensure_root
  echo "This will remove Smart-SSL files from this server."
  echo " - Binary: ${SMARTSSL_BIN}"
  echo " - Config dir: ${CONF_DIR} (including per-domain configs)"
  echo " - Cloudflare token file: ${CF_CREDS}"
  echo " - Deploy hook (if present)"
  echo "It will NOT delete Let's Encrypt certificates unless you confirm."
  read -rp "Proceed? (y/N): " ans
  [[ "${ans,,}" == "y" ]] || { echo "Aborted."; return 0; }

  local hook="/usr/local/bin/${APP}-deploy"
  rm -f "/etc/letsencrypt/renewal-hooks/deploy/99-${APP}-deploy" 2>/dev/null || true
  rm -f "$hook" 2>/dev/null || true

  mapfile -t _doms < <(grep -h '^domain=' "${DOM_DIR}"/**/*.conf "${DOM_DIR}"/*.conf 2>/dev/null | cut -d= -f2 || true)

  rm -rf "$CONF_DIR" 2>/dev/null || true
  rm -f "$CF_CREDS" 2>/dev/null || true

  read -rp "Also delete issued Let's Encrypt certificates for managed domains? (y/N): " purge
  if [[ "${purge,,}" == "y" ]]; then
    for d in "${_doms[@]}"; do
      [[ -n "$d" ]] && certbot delete --cert-name "$d" || true
    done
  fi

  rm -f "$SMARTSSL_BIN" 2>/dev/null || true
  echo "[*] Uninstalled."
}

menu() {
  ensure_root; ensure_paths; read_conf
  while true; do
    clear
    echo "=== Smart-SSL Main Menu ==="
    echo "1) Install dependencies"
    echo "2) Setup (email + Cloudflare token)"
    echo "3) Add / Issue certificate (PRODUCTION)"
    echo "4) Add / Issue certificate (STAGING / TEST)"
    echo "5) List managed domains"
    echo "6) Publish cert to custom path (reload hooks)"
    echo "7) Enable auto-renew (deploy hook + certbot.timer)"
    echo "8) Dry-run renewal test"
    echo "9) Rotate Cloudflare token"
    echo "10) Remove a domain"
    echo "11) Update Smart-SSL to latest"
    echo "12) Uninstall Smart-SSL"
    echo "0) Exit"
    echo
    read -rp "Select an option: " choice
    case "$choice" in
      1) cmd_install; read -rp "Press Enter to continue..." _ ;;
      2) cmd_setup; read -rp "Press Enter to continue..." _ ;;
      3) cmd_add; read -rp "Press Enter to continue..." _ ;;
      4) cmd_add_staging; read -rp "Press Enter to continue..." _ ;;
      5) cmd_list; read -rp "Press Enter to continue..." _ ;;
      6) read -rp "Domain to publish: " d; cmd_publish "$d"; read -rp "Press Enter to continue..." _ ;;
      7) cmd_enable_renew; read -rp "Press Enter to continue..." _ ;;
      8) cmd_dry_run; read -rp "Press Enter to continue..." _ ;;
      9) cmd_rotate_token; read -rp "Press Enter to continue..." _ ;;
      10) cmd_remove; read -rp "Press Enter to continue..." _ ;;
      11) cmd_self_update ;;   # restarts into new version
      12) cmd_uninstall ;;     # exits after uninstall
      0) clear; exit 0 ;;
      *) echo "Invalid option"; sleep 1 ;;
    esac
  done
}

# --- dispatcher ---
case "${1:-}" in
  install) shift; cmd_install "$@";;
  setup) shift; cmd_setup "$@";;
  add) shift; cmd_add "$@";;
  add-staging) shift; cmd_add_staging "$@";;
  list) shift; cmd_list "$@";;
  publish) shift; cmd_publish "${1:-}";;
  enable-renew) shift; cmd_enable_renew "$@";;
  rotate-token) shift; cmd_rotate_token "$@";;
  dry-run) shift; cmd_dry_run "$@";;
  remove) shift; cmd_remove "$@";;
  self-update) shift; cmd_self_update "$@";;
  uninstall) shift; cmd_uninstall "$@";;
  version) echo "${APP} ${VERSION}";;
  menu|'') menu ;;
  *) print_usage;;
esac
