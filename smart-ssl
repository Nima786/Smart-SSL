#!/usr/bin/env bash
# Smart-SSL v1.1.0
# Supports:
#   - Cloudflare DNS (automated, wildcard ok)
#   - Standard Certbot (standalone or webroot, no wildcard)
#   - Migration (import existing certs or convert to CF DNS)
# Auto-renew via certbot.timer, deploy hook publishes to per-domain path

set -Eeuo pipefail

APP="smart-ssl"
VERSION="1.1.0"

CONF_DIR="/etc/${APP}"
DOM_DIR="${CONF_DIR}/domains"
MAIN_CONF="${CONF_DIR}/config.ini"
CF_CREDS="/root/.secrets/cloudflare.ini"

DEFAULT_PROPAGATION=90

die() { echo "ERROR: $*" >&2; exit 1; }
ensure_root() { [[ ${EUID:-0} -eq 0 ]] || die "Run as root."; }
pause() { read -rp "Press Enter to continue..." _ || true; }

ensure_paths() {
  mkdir -p "$DOM_DIR"
  [[ -f "$MAIN_CONF" ]] || cat >"$MAIN_CONF" <<EOF
email=
propagation_seconds=${DEFAULT_PROPAGATION}
creds=${CF_CREDS}
EOF
}

read_conf() {
  unset "${!CFG_@}" || true
  while IFS='=' read -r k v; do
    [[ "$k" =~ ^[a-z_]+$ ]] || continue
    eval "CFG_${k^^}='${v}'"
  done < <(grep -E "^[a-z_]+=" "$MAIN_CONF" || true)
}

_valid_email() { [[ "$1" =~ ^[^@[:space:]]+@[^@[:space:]]+\.[^@[:space:]]+$ ]]; }
_valid_domain() { [[ "$1" =~ ^([a-zA-Z0-9]([-a-zA-Z0-9]*[a-zA-Z0-9])?\.)+[A-Za-z]{2,}$ ]]; }

domain_conf_path() { echo "${DOM_DIR}/$1.conf"; }

# --- Setup ---
cmd_setup() {
  ensure_root; ensure_paths; read_conf
  local email=""
  while true; do
    read -rp "Let's Encrypt email: " email
    _valid_email "$email" && break
    echo "Invalid email."
  done
  sed -i "s|^email=.*|email=${email}|" "$MAIN_CONF"
  echo "[*] Email saved: ${email}"
  systemctl enable --now certbot.timer || true
  echo "[*] Auto-renew enabled (certbot.timer)."
}

cmd_rotate_token() {
  ensure_root; ensure_paths; read_conf
  read -rp "Cloudflare API token: " token
  [[ -n "$token" ]] || die "Token cannot be empty"
  mkdir -p "$(dirname "$CF_CREDS")"
  printf 'dns_cloudflare_api_token = %s\n' "$token" > "$CF_CREDS"
  chmod 600 "$CF_CREDS"
  echo "[*] Saved token to $CF_CREDS"
}

# --- Issue certs ---
_issue_cert_cf() {
  local dom="$1" mode="$2" pub="$3"
  local force_flag=""
  [[ -d "/etc/letsencrypt/live/${dom}" ]] && force_flag="--force-renewal"
  local -a dargs
  if [[ "$mode" == "wildcard" ]]; then
    dargs=(-d "$dom" -d "*.$dom")
  else
    dargs=(-d "$dom")
  fi
  certbot certonly \
    --dns-cloudflare \
    --dns-cloudflare-credentials "$CF_CREDS" \
    --dns-cloudflare-propagation-seconds "${CFG_PROPAGATION_SECONDS:-$DEFAULT_PROPAGATION}" \
    "${dargs[@]}" \
    -m "${CFG_EMAIL}" --agree-tos --no-eff-email --non-interactive \
    $force_flag || return 1
  cat >"$(domain_conf_path "$dom")" <<EOF
domain=${dom}
mode=${mode}
publish_path=${pub}
method=cloudflare
EOF
  [[ -n "$pub" ]] && cmd_publish "$dom"
}

_issue_cert_std() {
  local dom="$1" challenge="$2" webroot="$3" pub="$4"
  local force_flag=""
  [[ -d "/etc/letsencrypt/live/${dom}" ]] && force_flag="--force-renewal"
  local -a extra=()
  if [[ "$challenge" == "webroot" ]]; then
    extra=(--webroot -w "$webroot")
  else
    extra=(--standalone)
  fi
  certbot certonly \
    "${extra[@]}" \
    -d "$dom" \
    -m "${CFG_EMAIL}" --agree-tos --no-eff-email --non-interactive \
    $force_flag || return 1
  cat >"$(domain_conf_path "$dom")" <<EOF
domain=${dom}
mode=simple
publish_path=${pub}
method=standard
EOF
  [[ -n "$pub" ]] && cmd_publish "$dom"
}

cmd_add_cf() {
  ensure_root; ensure_paths; read_conf
  read -rp "Domain: " dom
  _valid_domain "$dom" || die "Invalid domain"
  read -rp "Mode (simple|wildcard) [simple]: " mode
  mode="${mode:-simple}"
  read -rp "Publish path: " pub
  _issue_cert_cf "$dom" "$mode" "$pub"
}

cmd_add_std() {
  ensure_root; ensure_paths; read_conf
  read -rp "Domain: " dom
  _valid_domain "$dom" || die "Invalid domain"
  read -rp "Challenge (standalone|webroot) [standalone]: " ch
  ch="${ch:-standalone}"
  local webroot=""
  [[ "$ch" == "webroot" ]] && read -rp "Webroot path: " webroot
  read -rp "Publish path: " pub
  _issue_cert_std "$dom" "$ch" "$webroot" "$pub"
}

# --- Publish ---
cmd_publish() {
  local dom="$1"
  local conf; conf="$(domain_conf_path "$dom")"
  [[ -f "$conf" ]] || die "No config for $dom"
  source "$conf"
  local lineage="/etc/letsencrypt/live/${domain}"
  [[ -d "$lineage" ]] || die "No cert lineage for $dom"
  [[ -z "$publish_path" ]] && { echo "[*] No publish path set."; return; }
  mkdir -p "$publish_path"
  cp "${lineage}/privkey.pem" "${publish_path}/privkey.pem"
  cp "${lineage}/fullchain.pem" "${publish_path}/fullchain.pem"
  echo "[*] Published certs to $publish_path"
}

# --- List domains ---
cmd_list() {
  shopt -s nullglob
  for f in "$DOM_DIR"/*.conf; do
    d=$(grep '^domain=' "$f" | cut -d= -f2)
    pub=$(grep '^publish_path=' "$f" | cut -d= -f2)
    exp="n/a"
    [[ -f "/etc/letsencrypt/live/$d/cert.pem" ]] && \
      exp=$(openssl x509 -enddate -noout -in "/etc/letsencrypt/live/$d/cert.pem" | cut -d= -f2)
    printf -- "- %-25s publish: %-20s exp: %s\n" "$d" "${pub:-<LE path>}" "$exp"
  done
  shopt -u nullglob
}

# --- Change publish path ---
cmd_change_publish() {
  shopt -s nullglob
  mapfile -t files < <(printf "%s\n" "$DOM_DIR"/*.conf)
  shopt -u nullglob
  (( ${#files[@]} )) || { echo "(no domains)"; return; }
  local i=1
  for f in "${files[@]}"; do
    d=$(grep '^domain=' "$f" | cut -d= -f2)
    echo "  $i) $d"; ((i++))
  done
  read -rp "Choose: " c
  ((c>=1 && c<=${#files[@]})) || return
  local file="${files[$((c-1))]}"
  dom=$(grep '^domain=' "$file" | cut -d= -f2)
  read -rp "New publish path for $dom: " np
  sed -i "s|^publish_path=.*|publish_path=${np}|" "$file"
  cmd_publish "$dom"
}

# --- Remove ---
cmd_remove() {
  shopt -s nullglob
  mapfile -t files < <(printf "%s\n" "$DOM_DIR"/*.conf)
  shopt -u nullglob
  (( ${#files[@]} )) || { echo "(no domains)"; return; }
  local i=1
  for f in "${files[@]}"; do
    d=$(grep '^domain=' "$f" | cut -d= -f2)
    echo "  $i) $d"; ((i++))
  done
  read -rp "Choose: " c
  ((c>=1 && c<=${#files[@]})) || return
  local file="${files[$((c-1))]}"
  dom=$(grep '^domain=' "$file" | cut -d= -f2)
  read -rp "Also delete cert from LE? (y/N): " ans
  if [[ "${ans,,}" == "y" ]]; then
    certbot delete --cert-name "$dom" --non-interactive || true
    rm -f "/etc/letsencrypt/renewal/${dom}.conf"
  fi
  rm -f "$file"
  echo "[*] Removed $dom"
}

# --- Manual renew ---
cmd_manual_renew() {
  shopt -s nullglob
  for f in "$DOM_DIR"/*.conf; do
    dom=$(grep '^domain=' "$f" | cut -d= -f2)
    [[ -d "/etc/letsencrypt/live/$dom" ]] || continue
    echo "---- Dry-run: $dom ----"
    certbot renew --dry-run --cert-name "$dom" || true
  done
  shopt -u nullglob
}

# --- Migration ---
_list_lineages() { basename -a /etc/letsencrypt/live/* 2>/dev/null || true; }
_domains_from_renewal() {
  local name="$1" rf="/etc/letsencrypt/renewal/${name}.conf"
  [[ -f "$rf" ]] || return
  grep -E '^\s*domains\s*=' "$rf" | sed 's/^[^=]*=\s*//' | tr ',' ' '
}

cmd_import_existing() {
  mapfile -t LINS < <(_list_lineages)
  (( ${#LINS[@]} )) || { echo "(no certbot lineages)"; return; }
  local i=1; for l in "${LINS[@]}"; do echo "  $i) $l"; ((i++)); done
  read -rp "Choose: " c; ((c>=1 && c<=${#LINS[@]})) || return
  local pick="${LINS[$((c-1))]}"
  read -rp "Publish path for $pick: " pub
  cat >"$(domain_conf_path "$pick")" <<EOF
domain=${pick}
mode=simple
publish_path=${pub}
method=imported
EOF
  [[ -n "$pub" ]] && cmd_publish "$pick"
  echo "[*] Imported $pick"
}

cmd_convert_to_cf() {
  mapfile -t LINS < <(_list_lineages)
  (( ${#LINS[@]} )) || { echo "(no certbot lineages)"; return; }
  local i=1; for l in "${LINS[@]}"; do echo "  $i) $l"; ((i++)); done
  read -rp "Choose: " c; ((c>=1 && c<=${#LINS[@]})) || return
  local pick="${LINS[$((c-1))]}"
  local names; names=$(_domains_from_renewal "$pick")
  [[ -n "$names" ]] || die "No domains found in renewal file."
  local -a dargs=()
  for n in $names; do dargs+=(-d "$n"); done
  certbot certonly \
    --dns-cloudflare \
    --dns-cloudflare-credentials "$CF_CREDS" \
    --dns-cloudflare-propagation-seconds "${CFG_PROPAGATION_SECONDS:-$DEFAULT_PROPAGATION}" \
    --cert-name "$pick" \
    "${dargs[@]}" \
    -m "${CFG_EMAIL}" --agree-tos --no-eff-email --non-interactive --force-renewal || return 1
  echo "[*] Converted $pick to Cloudflare DNS"
}

# --- Menu ---
menu() {
  ensure_root; ensure_paths; read_conf
  while true; do
    clear
    echo "=== Smart-SSL v${VERSION} ==="
    echo "1) Setup (email + enable auto-renew)"
    echo "2) Add certificate (Cloudflare DNS)"
    echo "3) Add certificate (Standard Certbot: standalone/webroot)"
    echo "4) List domains"
    echo "5) Change publish path"
    echo "6) Manual renew / dry-run"
    echo "7) Rotate Cloudflare token"
    echo "8) Remove domain"
    echo "9) Import existing Certbot certificate (adopt)"
    echo "10) Convert existing Certbot cert to Cloudflare DNS"
    echo "0) Exit"
    read -rp "Select: " c
    case "$c" in
      1) cmd_setup; pause ;;
      2) cmd_add_cf; pause ;;
      3) cmd_add_std; pause ;;
      4) cmd_list; pause ;;
      5) cmd_change_publish; pause ;;
      6) cmd_manual_renew; pause ;;
      7) cmd_rotate_token; pause ;;
      8) cmd_remove; pause ;;
      9) cmd_import_existing; pause ;;
      10) cmd_convert_to_cf; pause ;;
      0) exit 0 ;;
    esac
  done
}

# --- Entrypoint ---
case "${1:-}" in
  menu|'') menu ;;
  setup) cmd_setup ;;
  add-cf) cmd_add_cf ;;
  add-std) cmd_add_std ;;
  list) cmd_list ;;
  publish) shift; cmd_publish "$1" ;;
  manual-renew) cmd_manual_renew ;;
  remove) cmd_remove ;;
  import) cmd_import_existing ;;
  convert-cf) cmd_convert_to_cf ;;
  rotate-token) cmd_rotate_token ;;
  *) echo "Usage: $APP [menu|setup|add-cf|add-std|list|publish <domain>|manual-renew|remove|import|convert-cf|rotate-token]" ;;
esac
