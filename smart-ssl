#!/usr/bin/env bash
set -Eeuo pipefail

APP="smart-ssl"
VERSION="0.5.0"

# --- Update source (for self-update) ---
SMARTSSL_REPO="${SMARTSSL_REPO:-Nima786/Smart-SSL}"
SMARTSSL_BRANCH="${SMARTSSL_BRANCH:-main}"
SMARTSSL_RAW_BASE="https://raw.githubusercontent.com/${SMARTSSL_REPO}/${SMARTSSL_BRANCH}"
SMARTSSL_BIN="/usr/local/bin/${APP}"

# --- Paths ---
CONF_DIR="/etc/${APP}"
DOM_DIR="${CONF_DIR}/domains"
MAIN_CONF="${CONF_DIR}/config.ini"
CF_CREDS="/root/.secrets/cloudflare.ini"
TMP_DIR="/run/${APP}"

# --- helpers ---
die() { echo "ERROR: $*" >&2; exit 1; }
have() { command -v "$1" >/dev/null 2>&1; }
ensure_root() { [[ ${EUID:-0} -eq 0 ]] || die "Run as root."; }

ensure_paths() {
  mkdir -p "$DOM_DIR" "$TMP_DIR"
  chmod 700 "$TMP_DIR"
  [[ -f "$MAIN_CONF" ]] || cat >"$MAIN_CONF" <<EOF
email=
propagation_seconds=90
creds=${CF_CREDS}
default_owner=root:root
default_chain_mode=copy
EOF
}

read_conf() {
  while IFS='=' read -r k v; do
    [[ "$k" =~ ^[a-z_]+$ ]] || continue
    eval "CFG_${k^^}='${v}'"
  done < <(grep -E "^[a-z_]+=" "$MAIN_CONF" || true)
}

print_usage() {
  echo "(Tip: run 'smart-ssl' with no arguments to open the interactive menu.)"
  cat <<USAGE
${APP} ${VERSION}

Commands:
  install                 Install/check dependencies
  setup                   First-time setup (email, Cloudflare token)
  add                     Add/issue a domain (PRODUCTION)  [prompts: domain, mode, publish path]
  add-staging             TEST issue using Let's Encrypt STAGING
  list                    List managed domains + expiry
  publish <domain>        Copy/symlink certs to custom path & run reload hooks
  enable-renew            Install deploy hook + enable certbot.timer
  rotate-token            Update Cloudflare API token
  dry-run                 Run 'certbot renew --dry-run'
  remove                  Remove a domain (optionally revoke/delete LE lineage)
  self-update             Fetch and install the latest smart-ssl from GitHub
  uninstall               Remove Smart-SSL (with prompts)
  version                 Print version
USAGE
}

check_deps() {
  local missing=()
  have certbot || missing+=("certbot")
  have openssl || missing+=("openssl")
  if ((${#missing[@]})); then
    echo "Missing deps: ${missing[*]}"
    echo "Installing..."
    apt update
    apt install -y certbot python3-certbot-dns-cloudflare openssl
  fi
  have certbot || die "certbot not installed"
}

domain_conf_path() { echo "${DOM_DIR}/$1.conf"; }

# --- commands ---
cmd_install() {
  ensure_root; ensure_paths
  echo "[*] Installing dependencies…"
  apt update
  apt install -y certbot python3-certbot-dns-cloudflare openssl
  echo "[*] Done."
}

_valid_email() {
  # quick heuristic
  [[ "$1" =~ ^[^@[:space:]]+@[^@[:space:]]+\.[^@[:space:]]+$ ]]
}

cmd_setup() {
  ensure_root; ensure_paths; read_conf

  # Email with validation
  local email=""
  while true; do
    read -rp "Let's Encrypt email: " email
    if _valid_email "$email"; then
      break
    else
      echo "Invalid email format. Please try again."
    fi
  done

  read -rp "Propagation seconds [${CFG_PROPAGATION_SECONDS:-90}]: " ps
  ps="${ps:-${CFG_PROPAGATION_SECONDS:-90}}"

  mkdir -p "$(dirname "$CF_CREDS")"

  # Prefer env var if provided; otherwise visible prompt (no Ctrl-D)
  token="${SMARTSSL_CF_TOKEN:-}"
  if [[ -z "$token" ]]; then
    read -rp "Cloudflare API token (paste then ENTER): " token
    echo
  fi
  token="${token//$'\r'/}"
  [[ -n "$token" ]] || die "Token cannot be empty."

  printf 'dns_cloudflare_api_token = %s\n' "$token" > "$CF_CREDS"
  chmod 600 "$CF_CREDS"

  sed -i "s|^email=.*|email=${email}|" "$MAIN_CONF"
  sed -i "s|^propagation_seconds=.*|propagation_seconds=${ps}|" "$MAIN_CONF"
  sed -i "s|^creds=.*|creds=${CF_CREDS}|" "$MAIN_CONF"

  echo "[*] Setup complete."
}

_build_dargs() {
  local dom="$1" mode="$2"
  local -a out=()
  if [[ "$mode" == "wildcard" ]]; then
    out+=("-d" "${dom}" "-d" "*.${dom}")
  else
    out+=("-d" "${dom}")
  fi
  printf '%s\n' "${out[@]}"
}

_issue_cert() {
  local staging_flag="$1"; shift
  certbot certonly \
    --dns-cloudflare \
    --dns-cloudflare-credentials "${CFG_CREDS}" \
    --dns-cloudflare-propagation-seconds "${CFG_PROPAGATION_SECONDS}" \
    "$@" \
    -m "${CFG_EMAIL}" --agree-tos --no-eff-email --non-interactive \
    ${staging_flag}
}

# Simplified issuance: only Domain, Mode, Publish path; rest = defaults
cmd_add_common() {
  local staging="${1:-0}"

  ensure_root; ensure_paths; read_conf; check_deps

  local dom mode pub
  read -rp "Domain (e.g., vpn.example.com or example.com): " dom
  while [[ -z "$dom" ]]; do read -rp "Domain cannot be empty. Enter domain: " dom; done

  read -rp "Mode (simple|wildcard) [simple]: " mode; mode="${mode:-simple}"
  if [[ "$mode" != "simple" && "$mode" != "wildcard" ]]; then
    echo "Invalid mode; defaulting to 'simple'."; mode="simple"
  fi

  read -rp "Publish path (empty=use LE path only): " pub

  # Defaults for advanced values
  local owner="${CFG_DEFAULT_OWNER:-root:root}"
  local chn="${CFG_DEFAULT_CHAIN_MODE:-copy}"
  local sans=""; local hooks=""

  local conf; conf=$(domain_conf_path "$dom")
  cat >"$conf" <<EOF
domain=${dom}
mode=${mode}
sans=${sans}
publish_path=${pub}
reload_hooks=${hooks}
owner=${owner}
key_mode=600
cert_mode=644
chain_mode=${chn}
EOF

  mapfile -t dargs < <(_build_dargs "$dom" "$mode")

  local flag=""
  if [[ "$staging" == "1" ]]; then
    echo "[*] Using Let's Encrypt STAGING (test only; not trusted by browsers/clients)."
    flag="--staging"
  fi

  _issue_cert "$flag" "${dargs[@]}"

  [[ -n "$pub" ]] && cmd_publish "$dom" || echo "[*] Issued. Using LE live path."
}

cmd_add()          { cmd_add_common 0; }
cmd_add_staging()  { cmd_add_common 1; }

cmd_list() {
  ensure_paths
  shopt -s nullglob
  for f in "${DOM_DIR}"/*.conf; do
    d=$(grep '^domain=' "$f" | cut -d= -f2)
    mode=$(grep '^mode=' "$f" | cut -d= -f2)
    pub=$(grep '^publish_path=' "$f" | cut -d= -f2)
    lineage="/etc/letsencrypt/live/${d}"
    exp="n/a"
    [[ -f "${lineage}/cert.pem" ]] && exp=$(openssl x509 -enddate -noout -in "${lineage}/cert.pem" 2>/dev/null | cut -d= -f2 || echo "n/a")
    echo "- ${d}  [${mode}]  publish: ${pub:-<LE path>}  expires: ${exp}"
  done
  shopt -u nullglob
}

cmd_publish() {
  ensure_root; ensure_paths
  local dom="${1:-}"; [[ -n "$dom" ]] || die "Usage: ${APP} publish <domain>"
  local conf; conf=$(domain_conf_path "$dom"); [[ -f "$conf" ]] || die "No config for ${dom}"
  # shellcheck disable=SC1090
  source <(sed 's/^/DOM_/' "$conf" | sed 's/DOM_owner/DOM_OWNER/')
  local lineage="/etc/letsencrypt/live/${DOM_domain}"
  [[ -d "$lineage" ]] || die "No LE lineage at ${lineage}. Issue cert first."

  if [[ -z "${DOM_publish_path}" ]]; then
    echo "[*] No publish path set; nothing to do."
    return 0
  fi

  mkdir -p "${DOM_publish_path}"

  if [[ "${DOM_chain_mode:-copy}" == "symlink" ]]; then
    ln -sfn "${lineage}/privkey.pem" "${DOM_publish_path}/privkey.pem"
    ln -sfn "${lineage}/fullchain.pem" "${DOM_publish_path}/fullchain.pem"
  else
    install -m "${DOM_key_mode:-600}" -o "${DOM_OWNER%:*}" -g "${DOM_OWNER#*:}" \
      "${lineage}/privkey.pem" "${DOM_publish_path}/privkey.pem"
    install -m "${DOM_cert_mode:-644}" -o "${DOM_OWNER%:*}" -g "${DOM_OWNER#*:}" \
      "${lineage}/fullchain.pem" "${DOM_publish_path}/fullchain.pem"
  fi

  IFS=',' read -ra cmds <<< "${DOM_reload_hooks}"
  for c in "${cmds[@]}"; do c=$(echo "$c" | xargs); [[ -n "$c" ]] && bash -lc "$c" || true; done
  echo "[*] Published to ${DOM_publish_path} and hooks executed."
}

cmd_enable_renew() {
  ensure_root
  local hook="/usr/local/bin/${APP}-deploy"
  # generate deploy hook inline (no extra repo file)
  cat >"$hook" <<'EOF'
#!/usr/bin/env bash
set -Eeuo pipefail
APP="smart-ssl"
CONF_DIR="/etc/${APP}"
DOM_DIR="${CONF_DIR}/domains"
BIN="/usr/local/bin/${APP}"
shopt -s nullglob
for conf in "${DOM_DIR}"/*.conf; do
  dom=$(grep '^domain=' "$conf" | cut -d= -f2)
  [[ -n "$dom" ]] && "${BIN}" publish "$dom" || true
done
shopt -u nullglob
EOF
  chmod 0755 "$hook"

  mkdir -p /etc/letsencrypt/renewal-hooks/deploy
  ln -sfn "$hook" "/etc/letsencrypt/renewal-hooks/deploy/99-${APP}-deploy"
  systemctl enable --now certbot.timer || true
  echo "[*] Auto-renew enabled with deploy hook."
}

cmd_rotate_token() {
  ensure_root; ensure_paths; read_conf
  token="${SMARTSSL_CF_TOKEN:-}"
  if [[ -z "$token" ]]; then
    read -rp "New Cloudflare API token (paste then ENTER): " token
    echo
  fi
  token="${token//$'\r'/}"
  [[ -n "$token" ]] || die "Token cannot be empty."
  printf 'dns_cloudflare_api_token = %s\n' "$token" > "$CFG_CREDS"
  chmod 600 "$CFG_CREDS"
  echo "[*] Updated token at ${CFG_CREDS}"
}

cmd_dry_run() { certbot renew --dry-run; }

cmd_remove() {
  ensure_root
  read -rp "Domain to remove: " dom
  local conf; conf=$(domain_conf_path "$dom"); [[ -f "$conf" ]] || die "Not found."
  read -rp "Also revoke and delete LE lineage for '${dom}'? (y/N): " ans
  if [[ "${ans,,}" == "y" ]]; then
    certbot delete --cert-name "$dom" || true
  fi
  rm -f "$conf"
  echo "[*] Removed domain config."
}

cmd_self_update() {
  ensure_root
  local tmp; tmp="$(mktemp)"
  local url="${SMARTSSL_RAW_BASE}/smart-ssl"

  echo "[*] Fetching latest Smart-SSL from: ${url}"
  if ! curl -fsSL "$url" -o "$tmp"; then
    rm -f "$tmp"; die "Download failed."
  fi
  grep -q '^APP="smart-ssl"$' "$tmp" || { rm -f "$tmp"; die "Downloaded file doesn't look like smart-ssl."; }

  echo "[*] Installing to ${SMARTSSL_BIN}"
  install -m 0755 "$tmp" "$SMARTSSL_BIN"
  rm -f "$tmp"

  echo "[*] Updated. Restarting Smart-SSL…"
  exec "$SMARTSSL_BIN" menu
}

cmd_uninstall() {
  ensure_root
  echo "This will remove Smart-SSL files from this server."
  echo " - Binary: ${SMARTSSL_BIN}"
  echo " - Config dir: ${CONF_DIR} (including per-domain configs)"
  echo " - Cloudflare token file: ${CF_CREDS}"
  echo " - Deploy hook (if present)"
  echo "It will NOT delete Let's Encrypt certificates unless you confirm."
  read -rp "Proceed? (y/N): " ans
  [[ "${ans,,}" == "y" ]] || { echo "Aborted."; return 0; }

  local hook="/usr/local/bin/${APP}-deploy"
  rm -f "/etc/letsencrypt/renewal-hooks/deploy/99-${APP}-deploy" 2>/dev/null || true
  rm -f "$hook" 2>/dev/null || true

  # capture domains before removing configs (for optional purge)
  mapfile -t _doms < <(grep -h '^domain=' "${DOM_DIR}"/**/*.conf "${DOM_DIR}"/*.conf 2>/dev/null | cut -d= -f2 || true)

  rm -rf "$CONF_DIR" 2>/dev/null || true
  rm -f "$CF_CREDS" 2>/dev/null || true

  read -rp "Also delete issued Let's Encrypt certificates for managed domains? (y/N): " purge
  if [[ "${purge,,}" == "y" ]]; then
    for d in "${_doms[@]}"; do
      [[ -n "$d" ]] && certbot delete --cert-name "$d" || true
    done
  fi

  rm -f "$SMARTSSL_BIN" 2>/dev/null || true
  echo "[*] Uninstalled."
}

menu() {
  ensure_root; ensure_paths; read_conf
  while true; do
    clear
    echo "=== Smart-SSL Main Menu ==="
    echo "1) Install dependencies"
    echo "2) Setup (email + Cloudflare token)"
    echo "3) Add / Issue certificate (PRODUCTION)"
    echo "4) Add / Issue certificate (STAGING / TEST)"
    echo "5) List managed domains"
    echo "6) Publish cert to custom path (reload hooks)"
    echo "7) Enable auto-renew (deploy hook + certbot.timer)"
    echo "8) Dry-run renewal test"
    echo "9) Rotate Cloudflare token"
    echo "10) Remove a domain"
    echo "11) Update Smart-SSL to latest"
    echo "12) Uninstall Smart-SSL"
    echo "0) Exit"
    echo
    read -rp "Select an option: " choice
    case "$choice" in
      1) cmd_install; read -rp "Press Enter to continue..." _ ;;
      2) cmd_setup; read -rp "Press Enter to continue..." _ ;;
      3) cmd_add; read -rp "Press Enter to continue..." _ ;;
      4) cmd_add_staging; read -rp "Press Enter to continue..." _ ;;
      5) cmd_list; read -rp "Press Enter to continue..." _ ;;
      6) read -rp "Domain to publish: " d; cmd_publish "$d"; read -rp "Press Enter to continue..." _ ;;
      7) cmd_enable_renew; read -rp "Press Enter to continue..." _ ;;
      8) cmd_dry_run; read -rp "Press Enter to continue..." _ ;;
      9) cmd_rotate_token; read -rp "Press Enter to continue..." _ ;;
      10) cmd_remove; read -rp "Press Enter to continue..." _ ;;
      11) cmd_self_update ;;   # restarts into new version
      12) cmd_uninstall ;;     # exits after uninstall
      0) clear; exit 0 ;;
      *) echo "Invalid option"; sleep 1 ;;
    esac
  done
}

# --- dispatcher ---
case "${1:-}" in
  install) shift; cmd_install "$@";;
  setup) shift; cmd_setup "$@";;
  add) shift; cmd_add "$@";;
  add-staging) shift; cmd_add_staging "$@";;
  list) shift; cmd_list "$@";;
  publish) shift; cmd_publish "${1:-}";;
  enable-renew) shift; cmd_enable_renew "$@";;
  rotate-token) shift; cmd_rotate_token "$@";;
  dry-run) shift; cmd_dry_run "$@";;
  remove) shift; cmd_remove "$@";;
  self-update) shift; cmd_self_update "$@";;
  uninstall) shift; cmd_uninstall "$@";;
  version) echo "${APP} ${VERSION}";;
  menu|'') menu ;;
  *) print_usage;;
esac
