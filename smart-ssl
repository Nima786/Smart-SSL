#!/usr/bin/env bash
# Smart-SSL v1.3.1 (Smarter list/remove, stable multi-domain)

set -Eeuo pipefail

APP="smart-ssl"
VERSION="1.3.1"

SMARTSSL_REPO="${SMARTSSL_REPO:-Nima786/Smart-SSL}"
SMARTSSL_BRANCH="${SMARTSSL_BRANCH:-main}"
SMARTSSL_RAW_BASE="https://raw.githubusercontent.com/${SMARTSSL_REPO}/${SMARTSSL_BRANCH}"
SMARTSSL_BIN="/usr/local/bin/${APP}"

CONF_DIR="/etc/${APP}"
DOM_DIR="${CONF_DIR}/domains"
MAIN_CONF="${CONF_DIR}/config.ini"
CF_CREDS="/root/.secrets/cloudflare.ini"
TMP_DIR="/run/${APP}"

DEFAULT_PROPAGATION=10
DEFAULT_KEY_MODE=600
DEFAULT_CERT_MODE=644

die() { echo "ERROR: $*" >&2; exit 1; }
have() { command -v "$1" >/dev/null 2>&1; }
ensure_root() { [[ ${EUID:-0} -eq 0 ]] || die "Run as root."; }
pause() { read -rp "Press Enter to continue..." _ || true; }

ensure_paths() {
  mkdir -p "$DOM_DIR" "$TMP_DIR"
  chmod 700 "$TMP_DIR"
  [[ -f "$MAIN_CONF" ]] || cat >"$MAIN_CONF" <<EOF
email=
propagation_seconds=${DEFAULT_PROPAGATION}
creds=${CF_CREDS}
EOF
}

read_conf() {
  unset "${!CFG_@}" || true
  while IFS='=' read -r k v; do
    [[ "$k" =~ ^[a-z_]+$ ]] || continue
    eval "CFG_${k^^}='${v}'"
  done < <(grep -E "^[a-z_]+=" "$MAIN_CONF" || true)
}

_valid_email()  { [[ "$1" =~ ^[^@[:space:]]+@[^@[:space:]]+\.[^@[:space:]]+$ ]]; }
_valid_domain() { [[ "$1" =~ ^([a-zA-Z0-9]([-a-zA-Z0-9]*[a-zA-Z0-9])?\.)+[A-Za-z]{2,}$ ]]; }

domain_conf_path() { echo "${DOM_DIR}/$1.conf"; }
lineage_path()     { echo "/etc/letsencrypt/live/$1"; }

check_deps() {
  local need=()
  have curl    || need+=(curl)
  have openssl || need+=(openssl)
  have certbot || need+=(certbot)
  if ! dpkg-query -W -f='${Status}' python3-certbot-dns-cloudflare 2>/dev/null | grep -q "install ok installed"; then
    need+=(python3-certbot-dns-cloudflare)
  fi
  if ((${#need[@]})); then
    echo "[*] Installing dependencies: ${need[*]}"
    apt update
    apt install -y curl openssl certbot python3-certbot-dns-cloudflare
  fi
}

# ---------- Cloudflare helpers ----------
_cf_read_token() {
  [[ -r "$CF_CREDS" ]] || return 2
  local t
  t="$(grep -E '^\s*dns_cloudflare_api_token\s*=' "$CF_CREDS" 2>/dev/null | sed 's/.*=\s*//')"
  [[ -n "$t" ]] || return 2
  printf '%s' "$t"
}

_cf_find_zone() {
  local dom="$1" token; token="$(_cf_read_token)" || return 2
  local candidate="$dom" resp id
  while [[ "$candidate" == *.* ]]; do
    resp="$(curl -fsS -H "Authorization: Bearer ${token}" -H "Content-Type: application/json" \
      "https://api.cloudflare.com/client/v4/zones?name=${candidate}&status=active" 2>/dev/null || true)"
    [[ -n "$resp" ]] || return 3
    if grep -q '"success":true' <<<"$resp" && grep -q "\"name\":\"${candidate}\"" <<<"$resp"; then
      id="$(grep -o '"id":"[a-f0-9]\{32\}"' <<<"$resp" | head -n1 | cut -d'"' -f4)"
      [[ -n "$id" ]] && { echo "${candidate} ${id}"; return 0; }
    fi
    candidate="${candidate#*.}"
  done
  return 1
}

# ---------- Certbot helpers ----------
_check_existing_cert() {
  local dom="$1" lin; lin="$(lineage_path "$dom")"
  if [[ -f "${lin}/cert.pem" ]]; then
    local exp; exp=$(openssl x509 -enddate -noout -in "${lin}/cert.pem" 2>/dev/null | cut -d= -f2 || echo "unknown")
    echo "[!] A certificate already exists for '${dom}'"
    echo "    Path: ${lin}"
    echo "    Expires: ${exp}"
    return 0
  fi
  return 1
}

_patch_renewal_files_ps() {
  local ps="${CFG_PROPAGATION_SECONDS:-$DEFAULT_PROPAGATION}"
  [[ -z "$ps" || "$ps" == "0" ]] && ps="$DEFAULT_PROPAGATION"
  shopt -s nullglob
  for f in /etc/letsencrypt/renewal/*.conf; do
    grep -q '^\s*authenticator\s*=\s*dns-cloudflare' "$f" || continue
    if grep -q '^\s*dns_cloudflare_propagation_seconds\s*=' "$f"; then
      sed -i "s/^\s*dns_cloudflare_propagation_seconds\s*=.*/dns_cloudflare_propagation_seconds = ${ps}/" "$f"
    else
      echo "dns_cloudflare_propagation_seconds = ${ps}" >> "$f"
    fi
  done
  shopt -u nullglob
}

# ---------- Install / Setup ----------
cmd_install() { ensure_root; ensure_paths; check_deps; echo "[*] Dependencies installed/verified."; }

_setup_status() {
  read_conf
  local em_ok=no cf_ok=no
  if [[ -n "${CFG_EMAIL:-}" ]] && _valid_email "${CFG_EMAIL}"; then em_ok=yes; fi
  if _cf_read_token >/dev/null 2>&1; then cf_ok=yes; fi
  echo "$em_ok $cf_ok"
}

cmd_setup() {
  ensure_root; ensure_paths; check_deps
  read_conf
  read -r EM_OK CF_OK < <(_setup_status)
  if [[ "$EM_OK" == "yes" && "$CF_OK" == "yes" ]]; then
    echo "[*] Already configured:"
    echo "    - Email: ${CFG_EMAIL}"
    echo "    - CF token: present"
    read -rp "Reconfigure email/token? (y/N): " ans || true
    [[ "${ans,,}" == "y" ]] || { echo "[*] Leaving setup unchanged."; return 0; }
  fi
  local email="${CFG_EMAIL:-}"
  while true; do
    if [[ -n "$email" ]]; then
      read -rp "Let's Encrypt email (e.g., example@gmail.com) [leave blank to keep current]: " in || true
      [[ -n "$in" ]] && email="$in"
      _valid_email "$email" && break
      echo "Invalid email format, try again."
    else
      read -rp "Let's Encrypt email (e.g., example@gmail.com): " in || true
      [[ -n "$in" ]] && email="$in"
      _valid_email "$email" && break
      echo "Invalid email format, try again."
    fi
  done
  sed -i "s|^email=.*|email=${email}|" "$MAIN_CONF"
  read -rp "Cloudflare API token (leave empty to keep current/skip): " token || true
  if [[ -n "$token" ]]; then
    mkdir -p "$(dirname "$CF_CREDS")"
    printf 'dns_cloudflare_api_token = %s\n' "$token" > "$CF_CREDS"
    chmod 600 "$CF_CREDS"
    echo "[*] Saved token to ${CF_CREDS}"
  fi
  systemctl enable --now certbot.timer || true
  local hook="/usr/local/bin/${APP}-deploy"
  cat >"$hook" <<'EOF'
#!/usr/bin/env bash
set -Eeuo pipefail
APP="smart-ssl"
CONF_DIR="/etc/${APP}"
DOM_DIR="${CONF_DIR}/domains"
BIN="/usr/local/bin/${APP}"
shopt -s nullglob
for conf in "${DOM_DIR}"/*.conf; do
  dom=$(grep '^domain=' "$conf" | cut -d= -f2)
  [[ -n "$dom" ]] && "${BIN}" publish "$dom" || true
done
shopt -u nullglob
EOF
  chmod 0755 "$hook"
  mkdir -p /etc/letsencrypt/renewal-hooks/deploy
  ln -sfn "$hook" "/etc/letsencrypt/renewal-hooks/deploy/99-${APP}-deploy"
  echo "[*] Setup complete:"
  echo "    - Email: ${email}"
  if _cf_read_token >/dev/null 2>&1; then echo "    - CF token: configured"; else echo "    - CF token: not set"; fi
  echo "    - Auto-renew: enabled (certbot.timer)"
  
    # Re-read the config from disk so the menu displays the new email immediately.
  read_conf
}

cmd_rotate_token() {
  ensure_root; ensure_paths
  read -rp "New Cloudflare API token: " token
  [[ -n "$token" ]] || { echo "[!] Empty token; nothing changed."; return 0; }
  mkdir -p "$(dirname "$CF_CREDS")"
  printf 'dns_cloudflare_api_token = %s\n' "$token" > "$CF_CREDS"
  chmod 600 "$CF_CREDS"
  echo "[*] Updated token at ${CF_CREDS}"
}

# ---------- Issue (Cloudflare) ----------
_issue_cert_cf() {
  local pub="$1"
  local domains_str="$2"
  local -a all_domains=()
  read -ra all_domains <<< "$domains_str"
  local primary_dom="${all_domains[0]}"

  read_conf

  if _cf_find_zone "$primary_dom" >/dev/null; then
    echo "[*] Cloudflare zone access OK for primary domain."
  else
    case $? in
      1) echo "[!] '${primary_dom}' (or parent) not in your Cloudflare account."; return 1;;
      2) echo "[!] Cloudflare token not found at ${CF_CREDS}. Configure in option 2."; return 1;;
      3) echo "[!] Cloudflare API query failed (token/permissions/network)."; return 1;;
      *) echo "[!] Unknown Cloudflare check error."; return 1;;
    esac
  fi

  local force_flag=""
  [[ -d "/etc/letsencrypt/live/${primary_dom}" ]] && force_flag="--force-renewal"

  local -a dargs=()
  for d in "${all_domains[@]}"; do
    dargs+=(-d "$d")
  done

  local ps="${CFG_PROPAGATION_SECONDS:-$DEFAULT_PROPAGATION}"; [[ -z "$ps" || "$ps" == "0" ]] && ps="$DEFAULT_PROPAGATION"

  certbot certonly \
    --dns-cloudflare \
    --dns-cloudflare-credentials "$CF_CREDS" \
    --dns-cloudflare-propagation-seconds "$ps" \
    --cert-name "$primary_dom" \
    "${dargs[@]}" \
    -m "${CFG_EMAIL}" --agree-tos --no-eff-email --non-interactive \
    $force_flag || return 1

  local mode_for_conf="simple"
  for d in "${all_domains[@]}"; do
    if [[ "$d" == "*."* ]]; then
      mode_for_conf="wildcard"
      break
    fi
  done

  cat >"$(domain_conf_path "$primary_dom")" <<EOF
domain=${primary_dom}
mode=${mode_for_conf}
publish_path=${pub}
method=cloudflare
EOF
  [[ -n "$pub" ]] && cmd_publish "$primary_dom" || echo "[*] Issued (LE live path)."
}

cmd_add_cf() {
  ensure_root; ensure_paths; read_conf; check_deps
  local dom_input pub
  local -a dom_array=()

  echo "Select the type of certificate you want to issue:"
  echo "  1) Simple Certificate (for one or more domains, issued individually)"
  echo "  2) Wildcard Certificate (for a single domain and its subdomains)"
  
  local choice
  while true; do
    read -rp "Enter number [1]: " choice
    choice="${choice:-1}"
    case "$choice" in
      1)
        read -rp "Enter domain(s), comma-separated: " dom_input
        local dom_input_cleaned=$(echo "$dom_input" | tr -d '[:space:]')
        IFS=',' read -ra dom_array <<< "$dom_input_cleaned"
        break
        ;;
      2)
        read -rp "Enter the single domain for the wildcard cert (e.g., example.com): " dom_input
        _valid_domain "$dom_input" || { echo "[!] Invalid domain format: '$dom_input'"; continue; }
        # A wildcard is treated as a single issuance event for a single primary domain
        dom_array=("$dom_input") # The array will contain only one item to loop over
        break
        ;;
      *) echo "[!] Invalid option. Please enter 1 or 2." ;;
    esac
  done

  if (( ${#dom_array[@]} == 0 )); then
    echo "[!] No domains provided."
    return 0
  fi

  # --- NEW LOOPING LOGIC START ---
  local i=1
  local total=${#dom_array[@]}
  for primary_dom in "${dom_array[@]}"; do
    echo
    echo "======================================================"
    echo "Processing domain ${i} of ${total}: ${primary_dom}"
    echo "======================================================"

    local -a domains_for_this_cert=()
    if [[ "$choice" -eq 2 ]]; then # If it's a wildcard request
      domains_for_this_cert=("$primary_dom" "*.$primary_dom")
    else # If it's a simple request
      _valid_domain "$primary_dom" || { echo "[!] Invalid domain format: '$primary_dom'. Skipping."; ((i++)); continue; }
      domains_for_this_cert=("$primary_dom")
    fi

    echo "[*] The following names will be included in this certificate:"
    printf "    - %s\n" "${domains_for_this_cert[@]}"
    echo

    read -rp "Publish path for '${primary_dom}' (empty=use LE path only): " pub

    if _check_existing_cert "$primary_dom"; then
      echo
      echo "A certificate for '${primary_dom}' already exists. What would you like to do?"
      echo "  1) Skip this domain and continue to the next"
      echo "  2) Force re-issue of the certificate"
      local reissue_choice
      while true; do
        read -rp "Enter number [1]: " reissue_choice
        reissue_choice="${reissue_choice:-1}"
        case "$reissue_choice" in
          1) echo "[*] Skipping ${primary_dom}."; break ;;
          2) break ;;
          *) echo "[!] Invalid option. Please enter 1 or 2." ;;
        esac
      done
      if [[ "$reissue_choice" -eq 1 ]]; then
        ((i++))
        continue # Skip to the next domain in the loop
      fi
    fi

    # Call the issuing function for EACH domain individually
    _issue_cert_cf "$pub" "${domains_for_this_cert[*]}" || echo "[!] Issue failed for ${primary_dom}."
    
    ((i++))
  done
  # --- NEW LOOPING LOGIC END ---
}

# ---------- Issue (Standard Certbot) ----------
_issue_cert_std() {
  local dom="$1" challenge="$2" webroot="$3" pub="$4"
  read_conf
  local force_flag=""
  [[ -d "/etc/letsencrypt/live/${dom}" ]] && force_flag="--force-renewal"
  local -a extra=()
  if [[ "$challenge" == "webroot" ]]; then
    [[ -d "$webroot" ]] || { echo "[!] Webroot does not exist: $webroot"; return 1; }
    extra=(--webroot -w "$webroot")
  else
    extra=(--standalone)
  fi
  certbot certonly "${extra[@]}" -d "$dom" \
    -m "${CFG_EMAIL}" --agree-tos --no-eff-email --non-interactive $force_flag || return 1
  cat >"$(domain_conf_path "$dom")" <<EOF
domain=${dom}
mode=simple
publish_path=${pub}
method=standard
EOF
  [[ -n "$pub" ]] && cmd_publish "$dom" || echo "[*] Issued (LE live path)."
}

cmd_add_std() {
  ensure_root; ensure_paths; read_conf; check_deps
  local dom ch webroot pub
  read -rp "Domain (no wildcards): " dom
  _valid_domain "$dom" || { echo "[!] Invalid domain."; return 0; }
  read -rp "Challenge (standalone|webroot) [standalone]: " ch; ch="${ch:-standalone}"
  [[ "$ch" == "webroot" ]] && read -rp "Webroot path (e.g. /var/www/html): " webroot
  read -rp "Publish path (empty=use LE path only): " pub
  if _check_existing_cert "$dom"; then
    read -rp "Force re-issue anyway? (y/N): " ans
    [[ "${ans,,}" == "y" ]] || { echo "[*] Skipped issuing for ${dom}."; return 0; }
  fi
  _issue_cert_std "$dom" "$ch" "${webroot:-}" "$pub" || echo "[!] Issue failed."
}

# ---------- Publish ----------
cmd_publish() {
  ensure_root; ensure_paths
  local dom="${1:-}"; [[ -n "$dom" ]] || { echo "[!] Usage: ${APP} publish <domain>"; return 0; }
  local conf; conf="$(domain_conf_path "$dom")"; [[ -f "$conf" ]] || { echo "[!] No config for ${dom}"; return 0; }
  source "$conf"
  local lineage="/etc/letsencrypt/live/${domain}"
  [[ -d "$lineage" ]] || { echo "[!] No LE lineage at ${lineage}"; return 0; }
  if [[ -z "${publish_path}" ]]; then
    echo "[*] No publish path set; nothing to do."
    return 0
  fi
  publish_path="$(echo -n "$publish_path" | sed 's:[[:space:]]\+$::')"
  [[ "${publish_path}" == */ ]] || publish_path="${publish_path}/"
  mkdir -p "${publish_path}"
  install -m "${DEFAULT_KEY_MODE}"  "${lineage}/privkey.pem"   "${publish_path}privkey.pem"
  install -m "${DEFAULT_CERT_MODE}" "${lineage}/fullchain.pem" "${publish_path}fullchain.pem"
  cp -f "${lineage}/chain.pem" "${publish_path}chain.pem" 2>/dev/null || true
  install -m "${DEFAULT_KEY_MODE}" "${lineage}/privkey.pem" "${publish_path}key.pem"
  echo "[*] Published ${domain} → ${publish_path}"
  echo "    (Tip: using a trailing '/' in paths is recommended, e.g. /var/lib/marzban/certs/)"
}

# ---------- Selectors ----------
# --- NEW --- This function is now "smarter" and shows all domains in the menu.
_select_domain_from_list() {
  shopt -s nullglob
  local files=( "${DOM_DIR}"/*.conf )
  shopt -u nullglob
  if (( ${#files[@]} == 0 )); then echo "(no managed domains yet)" >&2; return 1; fi

  local -a display_names=()
  local -a return_values=()
  
  for f in "${files[@]}"; do
    local d; d=$(grep -E '^domain=' "$f" 2>/dev/null | cut -d= -f2)
    [[ -n "$d" ]] || continue
    
    local lineage="/etc/letsencrypt/live/${d}"
    local display_name="$d (cert not found)"
    
    if [[ -f "${lineage}/cert.pem" ]]; then
      local sans
      sans=$(openssl x509 -in "${lineage}/cert.pem" -noout -text | \
             awk '/Subject Alternative Name/{flag=1; next} /X509v3/{flag=0} flag' | \
             tr -d ' ' | tr ',' '\n' | sed 's/^DNS://' | paste -sd ", " -)
      [[ -n "$sans" ]] && display_name="$sans" || display_name="$d"
    fi
    display_names+=("$display_name")
    return_values+=("$f")
  done

  echo "Select a certificate:" >&2
  local i=1
  for name in "${display_names[@]}"; do
    printf "  %d) %s\n" "$i" "$name" >&2
    ((i++))
  done
  
  if (( i == 1 )); then echo "(no managed domains yet)" >&2; return 1; fi
  echo "  0) Cancel" >&2
  
  local choice
  while true; do
    read -rp "Enter number: " choice
    [[ "$choice" =~ ^[0-9]+$ ]] || { echo "Enter a number." >&2; continue; }
    (( choice>=0 && choice< i )) || { echo "Out of range." >&2; continue; }
    break
  done
  (( choice == 0 )) && { echo "Cancelled." >&2; return 1; }

  # The function returns the config file path, which is what the calling functions expect.
  printf '%s\n' "${return_values[$((choice-1))]}"
}

_pick_from_array() {
  local varname="$1"; shift || true
  local arr=()
  eval "arr=(\"\${${varname}[@]}\" )"
  local n=${#arr[@]}
  (( n > 0 )) || { echo "(none)" >&2; return 1; }
  echo "Select an item:" >&2
  local i=1
  for x in "${arr[@]}"; do
    printf "  %d) %s\n" "$i" "$x" >&2
    ((i++))
  done
  echo "  0) Cancel" >&2
  local choice
  while true; do
    read -rp "Enter number: " choice
    [[ "$choice" =~ ^[0-9]+$ ]] || { echo "Enter a number." >&2; continue; }
    (( choice>=0 && choice<=n )) || { echo "Out of range." >&2; continue; }
    break
  done
  (( choice==0 )) && { echo "Cancelled." >&2; return 1; }
  printf '%s\n' "${arr[$((choice-1))]}"
}

# ---------- List / Change publish / Remove / Dry-run ----------
# --- NEW --- This function is now "smarter" and shows all domains in the list.
cmd_list() {
  ensure_paths
  shopt -s nullglob
  local any=0
  for f in "${DOM_DIR}"/*.conf; do
    any=1
    local d pub mode lineage exp

    # Read the basic info from the Smart-SSL config file
    d=$(grep '^domain=' "$f" | cut -d= -f2)
    pub=$(grep '^publish_path=' "$f" | cut -d= -f2)
    mode=$(grep '^mode=' "$f" | cut -d= -f2)
    lineage="/etc/letsencrypt/live/${d}"
    exp="n/a"

    # --- NEW, CLEANER DISPLAY LOGIC ---
    local display_name="$d (cert not found)"
    if [[ -f "${lineage}/cert.pem" ]]; then
      # Get the expiration date from the certificate
      exp=$(openssl x509 -enddate -noout -in "${lineage}/cert.pem" 2>/dev/null | cut -d= -f2 || echo "n/a")
      
      # Get the full list of domains (SANs) from the certificate
      local sans
      sans=$(openssl x509 -in "${lineage}/cert.pem" -noout -text | \
             awk '/Subject Alternative Name/{flag=1; next} /X509v3/{flag=0} flag' | \
             tr -d ' ' | tr ',' '\n' | sed 's/^DNS://' | paste -sd ", " -)
      
      # Use the full list of SANs for display if available
      [[ -n "$sans" ]] && display_name="$sans" || display_name="$d"
    fi

    # Determine the path to show: the custom path, or the real LE path as a fallback.
    local path_to_show="${pub:-$lineage}"

    # Use a clean, multi-line printf for perfect alignment.
    printf -- "- Domains: %s [%s]\n" "$display_name" "$mode"
    printf -- "    Path:    %s\n" "$path_to_show"
    printf -- "    Expires: %s\n\n" "$exp"
  done
  shopt -u nullglob
  (( any == 0 )) && echo "(no managed domains yet)"
  return 0
}

cmd_change_publish() {
  ensure_root; ensure_paths
  local file; file="$(_select_domain_from_list)" || return 0
  local dom curr
  dom=$(grep '^domain=' "$file" | cut -d= -f2)
  curr=$(grep '^publish_path=' "$file" | cut -d= -f2)
  echo "Hint: end directories with '/' (e.g. /var/lib/marzban/certs/)"
  read -rp "New publish path for '${dom}' (empty=use LE path only) [${curr}]: " np
  np="${np:-$curr}"
  np="$(echo -n "$np" | sed 's:[[:space:]]\+$::')"
  [[ -n "$np" && "${np}" != */ ]] && np="${np}/"
  sed -i "s|^publish_path=.*|publish_path=${np}|" "$file"
  echo "[*] Publishing to new path…"
  if cmd_publish "$dom"; then
    if [[ -n "$curr" && -n "$np" && "$curr" != "$np" && -d "$curr" ]]; then
      echo "[*] Old path detected: ${curr}"
      read -rp "Remove old copied certs in '${curr}' (privkey.pem/key.pem/fullchain.pem/chain.pem)? (y/N): " rmold
      if [[ "${rmold,,}" == "y" ]]; then
        rm -f "${curr%/}/privkey.pem" "${curr%/}/key.pem" "${curr%/}/fullchain.pem" "${curr%/}/chain.pem" 2>/dev/null || true
        echo "[*] Old files removed from ${curr}"
      fi
    fi
  else
    echo "[!] Publish failed; path updated in config but no files were copied."
  fi
}

cmd_remove() {
  ensure_root; ensure_paths
  local file; file="$(_select_domain_from_list)" || return 0
  local dom; dom=$(grep '^domain=' "$file" | cut -d= -f2)

  # --- NEW, SAFER CONFIRMATION LOGIC START ---
  local confirm_delete
  echo "[!] This will remove the domain '${dom}' from Smart-SSL management."
  read -rp "Are you sure you want to proceed? (y/N): " confirm_delete
  if [[ "${confirm_delete,,}" != "y" ]]; then
    echo "[*] Removal cancelled."
    return 0
  fi
  # --- NEW, SAFER CONFIRMATION LOGIC END ---

  local ans
  read -rp "Also delete the actual Let's Encrypt certificate for '${dom}'? (y/N): " ans
  if [[ "${ans,,}" == "y" ]]; then
    echo "[*] Deleting certbot lineage for ${dom}…"
    certbot delete --cert-name "$dom" --non-interactive || true
    rm -f "/etc/letsencrypt/renewal/${dom}.conf" 2>/dev/null || true
  fi
  
  rm -f "$file"
  echo "[*] Removed domain '${dom}' from Smart-SSL management."
}

cmd_manual_renew() {
  ensure_root; ensure_paths; read_conf
  echo "[*] Ensuring CF propagation seconds in renewal files: ${CFG_PROPAGATION_SECONDS:-$DEFAULT_PROPAGATION}s"
  _patch_renewal_files_ps
  echo "[*] Running dry-run for managed domains only…"
  shopt -s nullglob
  for f in "${DOM_DIR}"/*.conf; do
    local d; d=$(grep '^domain=' "$f" | cut -d= -f2)
    [[ -n "$d" && -d "/etc/letsencrypt/live/${d}" ]] || continue
    echo "---- Dry-run: ${d} ----"
    certbot renew --dry-run --cert-name "${d}" || true
  done
  shopt -u nullglob
}

# ---------- Migration ----------
_list_lineages_real() {
  shopt -s nullglob
  local out=()
  for d in /etc/letsencrypt/live/*; do
    [[ -d "$d" && -f "$d/cert.pem" ]] && out+=("$(basename "$d")")
  done
  printf '%s\n' "${out[@]}" | sort -u
  shopt -u nullglob
}

_domains_from_renewal() {
  local nm="${1:-}"
  local rf="/etc/letsencrypt/renewal/${nm}.conf"
  [[ -n "$nm" && -f "$rf" ]] || { echo ""; return 0; }
  grep -E '^\s*domains\s*=' "$rf" | sed 's/^[^=]*=\s*//' | tr ',' ' ' | tr -s ' ' || true
}

_domains_from_live_cert() {
  local nm="${1:-}"
  local cert="/etc/letsencrypt/live/${nm}/cert.pem"
  [[ -f "$cert" ]] || { echo ""; return 0; }
  local sans
  sans="$(openssl x509 -noout -text -in "$cert" 2>/dev/null \
        | awk '/Subject Alternative Name/{flag=1; next} /X509v3/{flag=0} flag' \
        | tr -d ' ' | tr ',' '\n' | sed -n 's/^DNS://p' \
        | tr '\n' ' ' | sed 's/[[:space:]]\+$//')"
  echo "${sans}"
}

cmd_import_existing() {
  ensure_root; ensure_paths
  mapfile -t LINS < <(_list_lineages_real)
  (( ${#LINS[@]} )) || { echo "(no real certbot lineages found)"; return 0; }
  managed=()
  if compgen -G "${DOM_DIR}/*.conf" >/dev/null; then
    managed_output=$(grep -h '^domain=' "${DOM_DIR}"/*.conf | cut -d= -f2)
    mapfile -t managed <<< "$managed_output"
  fi
  declare -A seen=(); for d in "${managed[@]}"; do seen["$d"]=1; done
  CANDS=(); for lin in "${LINS[@]}"; do [[ -n "${seen[$lin]:-}" ]] || CANDS+=("$lin"); done
  (( ${#CANDS[@]} )) || { echo "(nothing to import)"; return 0; }
  local pick; pick="$(_pick_from_array CANDS)" || return 0
  local pub=""; read -rp "Publish path for '${pick}' (empty=use LE path only): " pub
  cat >"$(domain_conf_path "$pick")" <<EOF
domain=${pick}
mode=simple
publish_path=${pub}
method=imported
EOF
  [[ -n "$pub" ]] && cmd_publish "$pick" || echo "[*] Imported '${pick}' (no publish path set)."
  echo "[*] Future renewals will auto-publish via deploy hook."
}

cmd_convert_to_cf() {
  ensure_root; ensure_paths; read_conf; check_deps
  if [[ ! -r "$CF_CREDS" ]]; then
    echo "[!] Cloudflare token file not found at ${CF_CREDS}."
    echo "    Please configure Cloudflare first via option 2 (Setup)."
    return 0
  fi
  mapfile -t LINS < <(_list_lineages_real)
  (( ${#LINS[@]} )) || { echo "(no real certbot lineages)"; return 0; }
  local pick; pick="$(_pick_from_array LINS)" || { echo "Cancelled."; return 0; }
  local names
  names="$(_domains_from_renewal "$pick" 2>/dev/null)"
  if [[ -z "$names" ]]; then
    echo "[*] Renewal file missing domains; using SANs from live certificate…"
    names="$(_domains_from_live_cert "$pick")"
  fi
  if [[ -z "$names" ]]; then
    echo "[!] Could not determine domain list for '${pick}' from renewal file or live certificate."
    return 0
  fi
  local -a dargs=()
  local n
  for n in $names; do dargs+=(-d "$n"); done
  local ps="${CFG_PROPAGATION_SECONDS:-$DEFAULT_PROPAGATION}"
  [[ -z "${ps:-}" || "$ps" == "0" ]] && ps="$DEFAULT_PROPAGATION"
  echo "[*] Reissuing '${pick}' with Cloudflare DNS (propagation ${ps}s)…"
  set +e
  certbot certonly \
    --dns-cloudflare \
    --dns-cloudflare-credentials "$CF_CREDS" \
    --dns-cloudflare-propagation-seconds "$ps" \
    --cert-name "$pick" \
    ${dargs[@]+"${dargs[@]}"} \
    -m "${CFG_EMAIL}" --agree-tos --no-eff-email --non-interactive \
    --force-renewal
  local rc=$?
  set -e
  if (( rc != 0 )); then echo "[!] Reissue failed (exit $rc)."; return 0; fi
  echo "[*] Converted '${pick}' to Cloudflare DNS."
  if [[ -f "$(domain_conf_path "$pick")" ]]; then cmd_publish "$pick" || true; fi
}

# ---------- Self-update / Uninstall ----------
cmd_self_update() {
  ensure_root
  local tmp; tmp="$(mktemp)"
  local url="${SMARTSSL_RAW_BASE}/smart-ssl"
  echo "[*] Fetching latest Smart-SSL from: ${url}"
  if ! curl -fsSL "$url" -o "$tmp"; then rm -f "$tmp"; echo "[!] Download failed."; return 0; fi
  grep -q '^APP="smart-ssl"$' "$tmp" || { rm -f "$tmp"; echo "[!] Downloaded file doesn't look like smart-ssl."; return 0; }
  install -m 0755 "$tmp" "$SMARTSSL_BIN"
  rm -f "$tmp"
  echo "[*] Updated. Restarting Smart-SSL…"
  exec "$SMARTSSL_BIN" menu
}

cmd_uninstall() {
  ensure_root
  echo "This will remove Smart-SSL from this server."
  echo " - Binary: ${SMARTSSL_BIN}"
  echo " - Config dir: ${CONF_DIR}"
  echo " - Cloudflare token file: ${CF_CREDS}"
  echo " - Deploy hook (renewal copy)"
  echo "It will NOT delete Let's Encrypt certificates unless you confirm."
  
  # --- FIX START ---
  local ans
  read -rp "Proceed with uninstall? (y/N): " ans
  if [[ "${ans,,}" != "y" ]]; then
    echo "Aborted."
    return 0
  fi

  set +e
  echo "[*] Removing deploy hook…"
  rm -f "/etc/letsencrypt/renewal-hooks/deploy/99-${APP}-deploy" 2>/dev/null
  rm -f "/usr/local/bin/${APP}-deploy" 2>/dev/null

  echo "[*] Collecting managed domains…"
  shopt -s nullglob
  local conf_files=( "${DOM_DIR}"/*.conf )
  shopt -u nullglob

  local _doms=()
  if ((${#conf_files[@]})); then
    mapfile -t _doms < <(grep -h '^domain=' "${conf_files[@]}" 2>/dev/null | cut -d= -f2)
  fi
  echo "    Found: ${#_doms[@]} domain(s)"

  local pubpaths=()
  if ((${#conf_files[@]})); then
    while IFS='=' read -r k v; do
      [[ "$k" == "publish_path" && -n "$v" ]] || continue
      v="$(echo -n "$v" | sed 's:[[:space:]]\+$::')"
      [[ "$v" == */ ]] || v="${v}/"
      pubpaths+=("$v")
    done < <(grep -h '^publish_path=' "${conf_files[@]}" 2>/dev/null)
  fi
  if ((${#pubpaths[@]})); then
    mapfile -t pubpaths < <(printf '%s\n' "${pubpaths[@]}" | awk '!seen[$0]++')
  fi

  if ((${#pubpaths[@]})); then
    echo "[*] Publish paths detected:"
    printf '    - %s\n' "${pubpaths[@]}"
    read -rp "Remove copied cert files from these paths (privkey.pem, key.pem, fullchain.pem, chain.pem)? (y/N): " rm_pub
    if [[ "${rm_pub,,}" == "y" ]]; then
      for p in "${pubpaths[@]}"; do
        rm -f "${p%/}/privkey.pem" "${p%/}/key.pem" "${p%/}/fullchain.pem" "${p%/}/chain.pem" 2>/dev/null || true
      done
      echo "[*] Removed copied cert files from publish paths."
    fi
  fi

  echo "[*] Removing Smart-SSL config directory…"
  rm -rf "$CONF_DIR" 2>/dev/null

  echo "[*] Removing Cloudflare token file (if present)…"
  rm -f "$CF_CREDS" 2>/dev/null

  if ((${#_doms[@]})); then
    read -rp "Also delete Let's Encrypt certificates for: ${_doms[*]} ? (y/N): " purge
    if [[ "${purge,,}" == "y" ]]; then
      for d in "${_doms[@]}"; do
        [[ -n "$d" ]] || continue
        echo "   - Deleting certbot lineage for ${d}…"
        certbot delete --cert-name "$d" --non-interactive || true
        rm -f "/etc/letsencrypt/renewal/${d}.conf" 2>/dev/null || true
      done
    fi
  fi

  shopt -s nullglob
  mapfile -t all_lins < <(for d in /etc/letsencrypt/live/*; do [[ -f "$d/cert.pem" ]] && basename "$d"; done)
  shopt -u nullglob

  declare -A managed_set=()
  for d in "${_doms[@]}"; do managed_set["$d"]=1; done

  local orphans=()
  for lin in "${all_lins[@]}"; do
    [[ -z "${managed_set[$lin]:-}" ]] && orphans+=("$lin")
  done

  if ((${#orphans[@]})); then
    echo "[*] Orphaned Let's Encrypt lineages (not managed by Smart-SSL): ${orphans[*]}"
    read -rp "Delete these as well (including any *-staging)? (y/N): " del_orphans
    if [[ "${del_orphans,,}" == "y" ]]; then
      for o in "${orphans[@]}"; do
        echo "   - Deleting lineage ${o}…"
        certbot delete --cert-name "$o" --non-interactive || true
        rm -f "/etc/letsencrypt/renewal/${o}.conf" 2>/dev/null || true
        rm -rf "/etc/letsencrypt/live/${o}" "/etc/letsencrypt/archive/${o}" 2>/dev/null || true
      done
    fi
  fi

  echo "[*] Removing Smart-SSL binary…"
  rm -f "$SMARTSSL_BIN" 2>/dev/null
  echo "[*] Uninstalled. (Exiting.)"
  exit 0
}

# ---------- UI Colors (safe for light & dark) ----------
init_colors() {
  local supports_color=0
  if [ -t 1 ] && command -v tput >/dev/null 2>&1; then
    if [ "$(tput colors 2>/dev/null || echo 0)" -ge 8 ]; then supports_color=1; fi
  fi
  if [[ $supports_color -eq 1 ]]; then
    BORD="\e[1;37m"; NUM="\e[36m"; TITLE="\e[36m"; RESET="\e[0m"; GOOD="\e[32m"; BAD="\e[31m"; WARN="\e[33m"
  else
    BORD=""; NUM=""; TITLE=""; RESET=""; GOOD=""; BAD=""; WARN=""
  fi
}

_setup_brief_status() {
  read -r EM_OK CF_OK < <(_setup_status)
  local em icon_setup icon_cf
  [[ "$EM_OK" == "yes" ]] && icon_setup="${GOOD}✅${RESET}" || icon_setup="${BAD}❌${RESET}"
  [[ "$CF_OK" == "yes" ]] && icon_cf="${GOOD}✅${RESET}" || icon_cf="${WARN}⚠${RESET}"
  em="${CFG_EMAIL:-not set}"
  echo -e "   Email: ${em}   CF token: ${icon_cf}   Setup: ${icon_setup}"
}

# ---------- Menu ----------
menu() {
  ensure_root; ensure_paths; read_conf
  init_colors
  while true; do
    clear
    echo -e "${BORD}======================================================${RESET}"
    echo -e "              ${TITLE}Smart-SSL v${VERSION}${RESET}"
    echo -e "${BORD}======================================================${RESET}"
    _setup_brief_status
    echo
    printf "   ${NUM}%2s)${RESET} %s\n" "1" "Install dependencies"
    printf "   ${NUM}%2s)${RESET} %s\n" "2" "Setup (email + Cloudflare token + enable auto-renew)"
    printf "   ${NUM}%2s)${RESET} %s\n" "3" "Add certificate (Cloudflare DNS)"
    printf "   ${NUM}%2s)${RESET} %s\n" "4" "Add certificate (Standard Certbot: standalone/webroot)"
    echo
    printf "   ${NUM}%2s)${RESET} %s\n" "5" "List managed domains"
    printf "   ${NUM}%2s)${RESET} %s\n" "6" "Change publish path & publish now"
    printf "   ${NUM}%2s)${RESET} %s\n" "7" "Manual renew / dry-run (managed domains only)"
    printf "   ${NUM}%2s)${RESET} %s\n" "8" "Rotate Cloudflare token"
    printf "   ${NUM}%2s)${RESET} %s\n" "9" "Remove a domain"
    echo
    printf "   ${NUM}%2s)${RESET} %s\n" "10" "Import existing Certbot certificate (adopt)"
    printf "   ${NUM}%2s)${RESET} %s\n" "11" "Convert existing Certbot cert to Cloudflare DNS"
    printf "   ${NUM}%2s)${RESET} %s\n" "12" "Self-update Smart-SSL"
    printf "   ${NUM}%2s)${RESET} %s\n" "13" "Uninstall Smart-SSL"
    echo
    printf "   ${NUM}%2s)${RESET} %s\n" "0" "Exit"
    echo
    read -rp "   Select an option: " choice
    case "$choice" in
      1) cmd_install; pause ;;
      2) cmd_setup; pause ;;
      3) cmd_add_cf; pause ;;
      4) cmd_add_std; pause ;;
      5) cmd_list; pause ;;
      6) cmd_change_publish; pause ;;
      7) cmd_manual_renew; pause ;;
      8) cmd_rotate_token; pause ;;
      9) cmd_remove; pause ;;
      10) cmd_import_existing; pause ;;
      11) cmd_convert_to_cf; pause ;;
      12) cmd_self_update ;;
      13) cmd_uninstall ;;
      0) clear; exit 0 ;;
      *) echo "Invalid option"; sleep 1 ;;
    esac
  done
}

# ---------- Dispatcher ----------
case "${1:-}" in
  menu|'') menu ;;
  install) cmd_install ;;
  setup) cmd_setup ;;
  add-cf) cmd_add_cf ;;
  add-std) cmd_add_std ;;
  list) cmd_list ;;
  publish) shift; cmd_publish "${1:-}" ;;
  change-publish) cmd_change_publish ;;
  manual-renew) cmd_manual_renew ;;
  rotate-token) cmd_rotate_token ;;
  remove) cmd_remove ;;
  import) cmd_import_existing ;;
  convert-cf) cmd_convert_to_cf ;;
  self-update) cmd_self_update ;;
  uninstall) cmd_uninstall ;;
  version) echo "${APP} ${VERSION}" ;;
  *) echo "Usage: $APP [menu|install|setup|add-cf|add-std|list|publish <domain>|change-publish|manual-renew|rotate-token|remove|import|convert-cf|self-update|uninstall|version]";;
esac
