#!/usr/bin/env bash
# Smart-SSL (no-staging) - v1.0.0
# Author: @nima78600
# Purpose: Simple SSL issuance & renewals using Certbot + Cloudflare DNS
# - Auto-renew enabled system-wide (certbot.timer) during setup
# - Per-domain publish path; published on first issue and on every renewal via deploy hook
# - No service reloads; just file copy/symlink (defaults to copying with safe perms)
# - No staging mode to keep UX simple
# - Dry-run tests only managed domains
# - Self-update & uninstall included

set -Eeuo pipefail

APP="smart-ssl"
VERSION="1.0.0"

# --- Repository for self-update ---
SMARTSSL_REPO="${SMARTSSL_REPO:-Nima786/Smart-SSL}"
SMARTSSL_BRANCH="${SMARTSSL_BRANCH:-main}"
SMARTSSL_RAW_BASE="https://raw.githubusercontent.com/${SMARTSSL_REPO}/${SMARTSSL_BRANCH}"
SMARTSSL_BIN="/usr/local/bin/${APP}"

# --- Paths ---
CONF_DIR="${SMARTSSL_CONF_DIR:-/etc/${APP}}"
DOM_DIR="${CONF_DIR}/domains"
MAIN_CONF="${CONF_DIR}/config.ini"
CF_CREDS="${SMARTSSL_CREDS_PATH:-/root/.secrets/cloudflare.ini}"
TMP_DIR="${SMARTSSL_TMP_DIR:-/run/${APP}}"

# --- Defaults (safe) ---
DEFAULT_PROPAGATION=90            # seconds for DNS TXT to propagate
DEFAULT_KEY_MODE=600
DEFAULT_CERT_MODE=644
DEFAULT_OWNER="root:root"
DEFAULT_CHAIN_MODE="copy"         # copy | symlink

# ========== helpers ==========
die() { echo "ERROR: $*" >&2; exit 1; }
have() { command -v "$1" >/dev/null 2>&1; }
ensure_root() { [[ ${EUID:-0} -eq 0 ]] || die "Run as root."; }
pause() { read -rp "Press Enter to continue..." _ || true; }

ensure_paths() {
  mkdir -p "$DOM_DIR" "$TMP_DIR"
  chmod 700 "$TMP_DIR"
  [[ -f "$MAIN_CONF" ]] || cat >"$MAIN_CONF" <<EOF
email=
propagation_seconds=${DEFAULT_PROPAGATION}
creds=${CF_CREDS}
default_owner=${DEFAULT_OWNER}
default_chain_mode=${DEFAULT_CHAIN_MODE}
key_mode=${DEFAULT_KEY_MODE}
cert_mode=${DEFAULT_CERT_MODE}
EOF
}

read_conf() {
  # Reset CFG_* (avoid stale values if user edited file)
  unset "${!CFG_@}" || true
  while IFS='=' read -r k v; do
    [[ "$k" =~ ^[a-z_]+$ ]] || continue
    eval "CFG_${k^^}='${v}'"
  done < <(grep -E "^[a-z_]+=" "$MAIN_CONF" || true)
}

domain_conf_path() { echo "${DOM_DIR}/$1.conf"; }
lineage_path()     { echo "/etc/letsencrypt/live/$1"; }

_valid_email()  { [[ "$1" =~ ^[^@[:space:]]+@[^@[:space:]]+\.[^@[:space:]]+$ ]]; }
_valid_domain() { [[ "$1" =~ ^([a-zA-Z0-9]([-a-zA-Z0-9]*[a-zA-Z0-9])?\.)+[A-Za-z]{2,}$ ]]; }

check_deps() {
  local missing=()
  have curl    || missing+=("curl")
  have openssl || missing+=("openssl")
  have certbot || missing+=("certbot")
  if ((${#missing[@]})); then
    echo "[*] Installing missing deps: ${missing[*]}"
    apt update
    apt install -y curl openssl certbot python3-certbot-dns-cloudflare
  fi
  have certbot || die "certbot not installed"
}

print_usage() {
  cat <<USAGE
${APP} ${VERSION}

Commands:
  menu                    Open interactive menu
  setup                   First-time setup (email + Cloudflare token + auto-renew)
  install                 Install/check dependencies
  add                     Issue certificate (PRODUCTION; simple|wildcard)
  list                    List managed domains + expiry
  publish <domain>        Copy/symlink certs to custom path
  change-publish          Numbered UI to change publish path (and publish)
  manual-renew            Dry-run all managed domains (tests flow)
  rotate-token            Update Cloudflare API token
  remove                  Remove a domain (numbered UI; optional delete certs)
  self-update             Fetch and install latest smart-ssl
  uninstall               Completely remove Smart-SSL (optional delete certs)
  version                 Print version
USAGE
}

# ========== Cloudflare helpers ==========
_cf_read_token() {
  [[ -r "$CFG_CREDS" ]] || return 2
  local t
  t="$(grep -E '^\s*dns_cloudflare_api_token\s*=' "$CFG_CREDS" 2>/dev/null | sed 's/.*=\s*//')"
  [[ -n "$t" ]] || return 2
  printf '%s' "$t"
}

# Look up zone in Cloudflare via API; prints "zone_name zone_id" if found
_cf_find_zone() {
  local dom="$1" token; token="$(_cf_read_token)" || return 2
  local candidate="$dom" resp id
  while [[ "$candidate" == *.* ]]; do
    resp="$(curl -fsS -H "Authorization: Bearer ${token}" -H "Content-Type: application/json" \
      "https://api.cloudflare.com/client/v4/zones?name=${candidate}&status=active" 2>/dev/null || true)"
    [[ -n "$resp" ]] || return 3
    if grep -q '"success":true' <<<"$resp" && grep -q "\"name\":\"${candidate}\"" <<<"$resp"; then
      id="$(grep -o '"id":"[a-f0-9]\{32\}"' <<<"$resp" | head -n1 | cut -d'"' -f4)"
      [[ -n "$id" ]] && { echo "${candidate} ${id}"; return 0; }
    fi
    candidate="${candidate#*.}"
  done
  return 1
}

# ========== Cert helpers ==========
_check_existing_cert() {
  local dom="$1"; local lin; lin="$(lineage_path "$dom")"
  if [[ -f "${lin}/cert.pem" ]]; then
    local exp; exp=$(openssl x509 -enddate -noout -in "${lin}/cert.pem" 2>/dev/null | cut -d= -f2 || echo "unknown")
    echo "[!] A certificate already exists for '${dom}'."
    echo "    Path: ${lin}"
    echo "    Expires: ${exp}"
    return 0
  fi
  return 1
}

_build_dargs() {
  local dom="$1" mode="$2"
  local -a out=()
  if [[ "$mode" == "wildcard" ]]; then
    out+=("-d" "${dom}" "-d" "*.${dom}")
  else
    out+=("-d" "${dom}")
  fi
  printf '%s\n' "${out[@]}"
}

_issue_cert() {
  local force_flag="$1"; shift 1
  local ps="${CFG_PROPAGATION_SECONDS:-$DEFAULT_PROPAGATION}"
  [[ -z "$ps" || "$ps" == "0" ]] && ps="$DEFAULT_PROPAGATION"
  certbot certonly \
    --dns-cloudflare \
    --dns-cloudflare-credentials "${CFG_CREDS}" \
    --dns-cloudflare-propagation-seconds "${ps}" \
    "$@" \
    -m "${CFG_EMAIL}" --agree-tos --no-eff-email --non-interactive \
    ${force_flag}
}

# Ensure renewal *.conf for managed domains have desired propagation seconds
_patch_renewal_files_ps() {
  local ps="${CFG_PROPAGATION_SECONDS:-$DEFAULT_PROPAGATION}"
  [[ -z "$ps" || "$ps" == "0" ]] && ps="$DEFAULT_PROPAGATION"
  shopt -s nullglob
  for f in /etc/letsencrypt/renewal/*.conf; do
    grep -q '^\s*authenticator\s*=\s*dns-cloudflare' "$f" || continue
    if grep -q '^\s*dns_cloudflare_propagation_seconds\s*=' "$f"; then
      sed -i "s/^\s*dns_cloudflare_propagation_seconds\s*=.*/dns_cloudflare_propagation_seconds = ${ps}/" "$f"
    else
      echo "dns_cloudflare_propagation_seconds = ${ps}" >> "$f"
    fi
  done
  shopt -u nullglob
}

# ========== Commands ==========
cmd_install() {
  ensure_root; ensure_paths; check_deps
  echo "[*] Dependencies installed/verified."
}

cmd_setup() {
  ensure_root; ensure_paths; read_conf; check_deps

  local email=""
  while true; do
    read -rp "Let's Encrypt email: " email
    _valid_email "$email" && break
    echo "Invalid email format, try again."
  done

  mkdir -p "$(dirname "$CF_CREDS")"
  local token="${SMARTSSL_CF_TOKEN:-}"
  if [[ -z "$token" ]]; then
    read -rp "Cloudflare API token: " token
    echo
  fi
  token="${token//$'\r'/}"
  [[ -n "$token" ]] || die "Token cannot be empty."

  printf 'dns_cloudflare_api_token = %s\n' "$token" > "$CF_CREDS"
  chmod 600 "$CF_CREDS"

  # Persist base config
  sed -i "s|^email=.*|email=${email}|" "$MAIN_CONF"
  sed -i "s|^propagation_seconds=.*|propagation_seconds=${DEFAULT_PROPAGATION}|" "$MAIN_CONF"
  sed -i "s|^creds=.*|creds=${CF_CREDS}|" "$MAIN_CONF"

  # Always enable system auto-renew
  systemctl enable --now certbot.timer || true

  # Install deploy hook (publish after renew)
  local hook="/usr/local/bin/${APP}-deploy"
  cat >"$hook" <<'EOF'
#!/usr/bin/env bash
set -Eeuo pipefail
APP="smart-ssl"
CONF_DIR="/etc/${APP}"
DOM_DIR="${CONF_DIR}/domains"
BIN="/usr/local/bin/${APP}"
shopt -s nullglob
for conf in "${DOM_DIR}"/*.conf; do
  dom=$(grep '^domain=' "$conf" | cut -d= -f2)
  [[ -n "$dom" ]] && "${BIN}" publish "$dom" || true
done
shopt -u nullglob
EOF
  chmod 0755 "$hook"
  mkdir -p /etc/letsencrypt/renewal-hooks/deploy
  ln -sfn "$hook" "/etc/letsencrypt/renewal-hooks/deploy/99-${APP}-deploy"

  echo "[*] Setup complete."
  echo "    - Email: ${email}"
  echo "    - Cloudflare creds: ${CF_CREDS}"
  echo "    - Propagation: ${DEFAULT_PROPAGATION}s"
  echo "    - Auto-renew (certbot.timer): enabled"
}

cmd_add() {
  ensure_root; ensure_paths; read_conf; check_deps

  local dom mode pub
  read -rp "Domain (e.g., example.com or vpn.example.com): " dom
  while true; do
    [[ -n "$dom" ]] && _valid_domain "$dom" && break
    read -rp "Invalid domain, enter again: " dom
  done

  # CF zone check
  if _cf_find_zone "$dom" >/dev/null; then
    echo "[*] Cloudflare zone access OK."
  else
    case $? in
      1) echo "[!] '${dom}' or its parent zone is not in your Cloudflare account."; return 1;;
      2) echo "[!] Cloudflare token not found or unreadable at ${CFG_CREDS}. Run setup first."; return 1;;
      3) echo "[!] Cloudflare API query failed. Check network and token permissions."; return 1;;
      *) echo "[!] Unknown CF check error."; return 1;;
    esac
  fi

  read -rp "Mode (simple|wildcard) [simple]: " mode; mode="${mode:-simple}"
  if [[ "$mode" != "simple" && "$mode" != "wildcard" ]]; then
    echo "Invalid mode; defaulting to 'simple'."; mode="simple"
  fi

  read -rp "Publish path (empty=use LE path only): " pub

  # Existing cert?
  local force_flag=""
  if _check_existing_cert "$dom"; then
    read -rp "Force re-issue anyway? (y/N): " ans
    [[ "${ans,,}" == "y" ]] || { echo "[*] Skipped issuing for ${dom}."; return 0; }
    force_flag="--force-renewal"
  fi

  # Build domain args and issue
  mapfile -t dargs < <(_build_dargs "$dom" "$mode")
  if _issue_cert "$force_flag" "${dargs[@]}"; then
    # Save domain config only on success
    local conf_tmp="${TMP_DIR}/${dom}.conf.tmp"
    cat >"$conf_tmp" <<EOF
domain=${dom}
mode=${mode}
publish_path=${pub}
owner=${CFG_DEFAULT_OWNER:-$DEFAULT_OWNER}
key_mode=${CFG_KEY_MODE:-$DEFAULT_KEY_MODE}
cert_mode=${CFG_CERT_MODE:-$DEFAULT_CERT_MODE}
chain_mode=${CFG_DEFAULT_CHAIN_MODE:-$DEFAULT_CHAIN_MODE}
EOF
    install -m 0644 "$conf_tmp" "$(domain_conf_path "$dom")"
    rm -f "$conf_tmp"

    # Publish if path set
    [[ -n "$pub" ]] && cmd_publish "$dom" || echo "[*] Issued (using Let's Encrypt live path)."
  else
    echo "[!] Issuance failed for ${dom}. No config saved."
    return 1
  fi
}

cmd_list() {
  ensure_paths
  shopt -s nullglob
  local any=0
  for f in "${DOM_DIR}"/*.conf; do
    any=1
    local d pub mode lineage exp
    d=$(grep '^domain=' "$f" | cut -d= -f2)
    pub=$(grep '^publish_path=' "$f" | cut -d= -f2)
    mode=$(grep '^mode=' "$f" | cut -d= -f2)
    lineage="/etc/letsencrypt/live/${d}"
    exp="n/a"
    [[ -f "${lineage}/cert.pem" ]] && exp=$(openssl x509 -enddate -noout -in "${lineage}/cert.pem" 2>/dev/null | cut -d= -f2 || echo "n/a")
    printf -- "- %-30s [%s]  publish: %-22s  expires: %s\n" "$d" "$mode" "${pub:-<LE path>}" "$exp"
  done
  shopt -u nullglob
  (( any == 0 )) && echo "(no managed domains yet)"
  return 0
}

cmd_publish() {
  ensure_root; ensure_paths
  local dom="${1:-}"; [[ -n "$dom" ]] || die "Usage: ${APP} publish <domain>"
  local conf; conf="$(domain_conf_path "$dom")"; [[ -f "$conf" ]] || die "No config for ${dom}"

  # Read config safely into DOM_* vars
  # shellcheck disable=SC1090
  source <(sed 's/^/DOM_/' "$conf" | sed 's/DOM_owner/DOM_OWNER/')
  local lineage="/etc/letsencrypt/live/${DOM_domain}"
  [[ -d "$lineage" ]] || die "No LE lineage at ${lineage}. Issue cert first."

  if [[ -z "${DOM_publish_path}" ]]; then
    echo "[*] No publish path set; nothing to do."
    return 0
  fi

  mkdir -p "${DOM_publish_path}"
  if [[ "${DOM_chain_mode:-$DEFAULT_CHAIN_MODE}" == "symlink" ]]; then
    ln -sfn "${lineage}/privkey.pem"   "${DOM_publish_path}/privkey.pem"
    ln -sfn "${lineage}/fullchain.pem" "${DOM_publish_path}/fullchain.pem"
  else
    install -m "${DOM_key_mode:-$DEFAULT_KEY_MODE}"  -o "${DOM_OWNER%:*}" -g "${DOM_OWNER#*:}" "${lineage}/privkey.pem"   "${DOM_publish_path}/privkey.pem"
    install -m "${DOM_cert_mode:-$DEFAULT_CERT_MODE}" -o "${DOM_OWNER%:*}" -g "${DOM_OWNER#*:}" "${lineage}/fullchain.pem" "${DOM_publish_path}/fullchain.pem"
  fi

  echo "[*] Published ${DOM_domain} → ${DOM_publish_path}"
}

# --- Numbered domain selector that prints list even when command-substituted ---
_select_domain_from_list() {
  shopt -s nullglob
  mapfile -t files < <(printf "%s\n" "${DOM_DIR}"/*.conf 2>/dev/null || true)
  shopt -u nullglob
  local n=${#files[@]}
  (( n > 0 )) || { echo "(no managed domains)" >&2; return 1; }

  echo "Select a domain:" >&2
  local i=1 d
  for f in "${files[@]}"; do
    d=$(grep '^domain=' "$f" | cut -d= -f2)
    printf "  %d) %s\n" "$i" "$d" >&2
    ((i++))
  done
  echo "  0) Cancel" >&2

  local choice
  while true; do
    read -rp "Enter number: " choice
    [[ "$choice" =~ ^[0-9]+$ ]] || { echo "Enter a number." >&2; continue; }
    (( choice>=0 && choice<=n )) || { echo "Out of range." >&2; continue; }
    break
  done
  (( choice == 0 )) && { echo "Cancelled." >&2; return 1; }
  printf '%s\n' "${files[$((choice-1))]}"   # only path to stdout
}

cmd_change_publish() {
  ensure_root; ensure_paths
  local file; file="$(_select_domain_from_list)" || return 0
  local dom curr
  dom=$(grep '^domain=' "$file" | cut -d= -f2)
  curr=$(grep '^publish_path=' "$file" | cut -d= -f2)
  read -rp "New publish path for '${dom}' (empty=use LE path only) [${curr}]: " np
  np="${np:-$curr}"
  sed -i "s|^publish_path=.*|publish_path=${np}|" "$file"
  echo "[*] Updated. Publishing now…"
  cmd_publish "$dom"
}

cmd_manual_renew() {
  ensure_root; ensure_paths; read_conf
  echo "[*] Ensuring propagation seconds in renewal files: ${CFG_PROPAGATION_SECONDS:-$DEFAULT_PROPAGATION}s"
  _patch_renewal_files_ps
  echo "[*] Running dry-run for managed domains only…"
  shopt -s nullglob
  for f in "${DOM_DIR}"/*.conf; do
    local d; d=$(grep '^domain=' "$f" | cut -d= -f2)
    [[ -n "$d" ]] || continue
    [[ -d "/etc/letsencrypt/live/${d}" ]] || continue
    echo "---- Dry-run: ${d} ----"
    certbot renew --dry-run --cert-name "${d}" || true
  done
  shopt -u nullglob
}

cmd_rotate_token() {
  ensure_root; ensure_paths; read_conf
  local token="${SMARTSSL_CF_TOKEN:-}"
  if [[ -z "$token" ]]; then
    read -rp "New Cloudflare API token: " token
    echo
  end_if=
  fi
  token="${token//$'\r'/}"
  [[ -n "$token" ]] || die "Token cannot be empty."
  printf 'dns_cloudflare_api_token = %s\n' "$token" > "$CFG_CREDS"
  chmod 600 "$CFG_CREDS"
  echo "[*] Updated token at ${CFG_CREDS}"
}

cmd_remove() {
  ensure_root; ensure_paths
  local file; file="$(_select_domain_from_list)" || return 0
  local dom; dom=$(grep '^domain=' "$file" | cut -d= -f2)

  read -rp "Also revoke and delete Let's Encrypt cert for '${dom}'? (y/N): " ans
  if [[ "${ans,,}" == "y" ]]; then
    certbot delete --cert-name "$dom" || true
    rm -f "/etc/letsencrypt/renewal/${dom}.conf" 2>/dev/null || true
  fi

  rm -f "$file"
  echo "[*] Removed domain '${dom}'."
}

cmd_self_update() {
  ensure_root
  local tmp; tmp="$(mktemp)"
  local url="${SMARTSSL_RAW_BASE}/smart-ssl"
  echo "[*] Fetching latest Smart-SSL from: ${url}"
  if ! curl -fsSL "$url" -o "$tmp"; then
    rm -f "$tmp"; die "Download failed."
  fi
  grep -q '^APP="smart-ssl"$' "$tmp" || { rm -f "$tmp"; die "Downloaded file doesn't look like smart-ssl."; }
  install -m 0755 "$tmp" "$SMARTSSL_BIN"
  rm -f "$tmp"
  echo "[*] Updated. Restarting Smart-SSL…"
  exec "$SMARTSSL_BIN" menu
}

cmd_uninstall() {
  ensure_root
  echo "This will remove Smart-SSL from this server."
  echo " - Binary: ${SMARTSSL_BIN}"
  echo " - Config dir: ${CONF_DIR} (including per-domain configs)"
  echo " - Cloudflare token file: ${CF_CREDS}"
  echo " - Deploy hook (renewal copy)"
  echo "It will NOT delete Let's Encrypt certificates unless you confirm."
  read -rp "Proceed? (y/N): " ans
  [[ "${ans,,}" == "y" ]] || { echo "Aborted."; return 0; }

  # Remove deploy hook
  rm -f "/etc/letsencrypt/renewal-hooks/deploy/99-${APP}-deploy" 2>/dev/null || true
  rm -f "/usr/local/bin/${APP}-deploy" 2>/dev/null || true

  # Remember managed domains before removing configs (for optional cert deletion)
  shopt -s nullglob
  mapfile -t _doms < <(grep -h '^domain=' "${DOM_DIR}"/*.conf 2>/dev/null | cut -d= -f2 || true)
  shopt -u nullglob

  rm -rf "$CONF_DIR" 2>/dev/null || true
  rm -f "$CF_CREDS" 2>/dev/null || true

  read -rp "Also delete issued Let's Encrypt certificates for managed domains? (y/N): " purge
  if [[ "${purge,,}" == "y" ]]; then
    for d in "${_doms[@]}"; do
      [[ -n "$d" ]] && certbot delete --cert-name "$d" || true
      rm -f "/etc/letsencrypt/renewal/${d}.conf" 2>/dev/null || true
    done
  fi

  rm -f "$SMARTSSL_BIN" 2>/dev/null || true
  echo "[*] Uninstalled."
}

menu() {
  ensure_root; ensure_paths; read_conf
  set +e
  while true; do
    clear
    echo "=== Smart-SSL (no-staging) v${VERSION} ==="
    echo "1) Install dependencies"
    echo "2) Setup (email + Cloudflare token + enable auto-renew)"
    echo "3) Add / Issue certificate (PRODUCTION)"
    echo "4) List managed domains"
    echo "5) Change publish path & publish now"
    echo "6) Manual renew / dry-run (managed domains only)"
    echo "7) Rotate Cloudflare token"
    echo "8) Remove a domain"
    echo "9) Self-update Smart-SSL"
    echo "10) Uninstall Smart-SSL"
    echo "0) Exit"
    echo
    read -rp "Select an option: " choice
    case "$choice" in
      1) cmd_install; pause ;;
      2) cmd_setup; pause ;;
      3) cmd_add; pause ;;
      4) cmd_list; pause ;;
      5) cmd_change_publish; pause ;;
      6) cmd_manual_renew; pause ;;
      7) cmd_rotate_token; pause ;;
      8) cmd_remove; pause ;;
      9) cmd_self_update ;;   # restarts into new version
      10) cmd_uninstall ;;    # exits after uninstall
      0) clear; set -e; exit 0 ;;
      *) echo "Invalid option"; sleep 1 ;;
    esac
  done
}

# ========== Dispatcher ==========
case "${1:-}" in
  menu|'') menu ;;
  setup) cmd_setup ;;
  install) cmd_install ;;
  add) cmd_add ;;
  list) cmd_list ;;
  publish) shift; cmd_publish "${1:-}";;
  change-publish) cmd_change_publish ;;
  manual-renew) cmd_manual_renew ;;
  rotate-token) cmd_rotate_token ;;
  remove) cmd_remove ;;
  self-update) cmd_self_update ;;
  uninstall) cmd_uninstall ;;
  version) echo "${APP} ${VERSION}" ;;
  *) print_usage ;;
esac
